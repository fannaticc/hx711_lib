Disassembly Listing for hx711_lib_simple
Generated From:
C:/Users/Raphael/Desktop/hx711_lib_simple.X/dist/default/production/hx711_lib_simple.X.production.elf
Jul 10, 2019 4:17:22 PM

---  C:/Users/Raphael/Desktop/hx711_lib_simple.X/mcc_generated_files/spi_driver.c  ----------------------
1:             /*
2:                 (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
3:                 software and any derivatives exclusively with Microchip products.
4:             
5:                 THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
6:                 EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
7:                 WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
8:                 PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
9:                 WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:            
11:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
12:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
13:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
14:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
15:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
16:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
17:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
18:            
19:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
20:                TERMS.
21:            */
22:            
23:            #include <stdio.h>
24:            #include <stdint.h>
25:            #include <stdbool.h>
26:            #include <xc.h>
27:            #include "spi_driver.h"
28:            
29:            #pragma warning disable 520     
30:            
31:            void (*spi_interruptHandler)(void);   
32:            
33:            inline void spi_close(void)
34:            {
35:                SSP1CON1bits.SSPEN = 0;
36:            }
37:            
38:            //con1 == SSPxCON1, stat == SSPxSTAT, add == SSPxADD, operation == Master/Slave
39:            typedef struct { uint8_t con1; uint8_t stat; uint8_t add; uint8_t operation; } spi_configuration_t;
40:            static const spi_configuration_t spi_configuration[] = {
41:                { 0xa, 0x40, 0x1, 0 },
42:                { 0xa, 0x0, 0x1, 0 }
43:            };
44:            
45:            //Setup SPI
46:            bool spi_open(spi_modes spiUniqueConfiguration)
167D  00F3     MOVWF exp
47:            {
48:                if(!SSP1CON1bits.SSPEN)
167E  0024     MOVLB 0x4
167F  1A95     BTFSC SSP1CON1, 0x5
1680  2ED3     GOTO 0x6D3
49:                {
50:                    //setup PPS pins
51:                    SSPCLKPPS = 14;
1681  300E     MOVLW 0xE
1682  003C     MOVLB 0x1C
1683  00A0     MOVWF SSPCLKPPS
52:                    SSPDATPPS = 13;
1684  300D     MOVLW 0xD
1685  00A1     MOVWF SSPDATPPS
53:                    RB6PPS = 16;
1686  3010     MOVLW 0x10
1687  003D     MOVLB 0x1D
1688  009E     MOVWF RB6PPS
54:            
55:                    //setup SPI
56:                    SSP1STAT = spi_configuration[spiUniqueConfiguration].stat;
1689  0873     MOVF 0xEF3, W
168A  00F0     MOVWF 0xEF0
168B  01F1     CLRF 0xEF1
168C  35F0     LSLF 0xEF0, F
168D  0DF1     RLF 0xEF1, F
168E  35F0     LSLF 0xEF0, F
168F  0DF1     RLF 0xEF1, F
1690  30B9     MOVLW 0xB9
1691  0770     ADDWF 0xEF0, W
1692  0084     MOVWF FSR0L
1693  3098     MOVLW 0x98
1694  3D71     ADDWFC 0xEF1, W
1695  0085     MOVWF FSR0H
1696  0800     MOVF INDF0, W
1697  0024     MOVLB 0x4
1698  0094     MOVWF SSP1STAT
57:                    SSP1CON1 = (uint8_t)(spi_configuration[spiUniqueConfiguration].con1 | 0x20);
1699  0873     MOVF 0x273, W
169A  00F0     MOVWF 0x270
169B  01F1     CLRF 0x271
169C  35F0     LSLF 0x270, F
169D  0DF1     RLF 0x271, F
169E  35F0     LSLF 0x270, F
169F  0DF1     RLF 0x271, F
16A0  30B8     MOVLW 0xB8
16A1  0770     ADDWF 0x270, W
16A2  0084     MOVWF FSR0L
16A3  3098     MOVLW 0x98
16A4  3D71     ADDWFC 0x271, W
16A5  0085     MOVWF FSR0H
16A6  0800     MOVF INDF0, W
16A7  3820     IORLW 0x20
16A8  0095     MOVWF SSP1CON1
58:                    SSP1CON2 = 0x00;
16A9  0196     CLRF SSP1CON2
59:                    SSP1ADD  = (uint8_t)(spi_configuration[spiUniqueConfiguration].add);
16AA  0873     MOVF 0x273, W
16AB  00F0     MOVWF 0x270
16AC  01F1     CLRF 0x271
16AD  35F0     LSLF 0x270, F
16AE  0DF1     RLF 0x271, F
16AF  35F0     LSLF 0x270, F
16B0  0DF1     RLF 0x271, F
16B1  30BA     MOVLW 0xBA
16B2  0770     ADDWF 0x270, W
16B3  0084     MOVWF FSR0L
16B4  3098     MOVLW 0x98
16B5  3D71     ADDWFC 0x271, W
16B6  0085     MOVWF FSR0H
16B7  0800     MOVF INDF0, W
16B8  0092     MOVWF SSP1ADD
60:            
61:                    TRISBbits.TRISB6 = (uint8_t)(spi_configuration[spiUniqueConfiguration].operation);
16B9  0873     MOVF 0x273, W
16BA  00F0     MOVWF 0x270
16BB  01F1     CLRF 0x271
16BC  35F0     LSLF 0x270, F
16BD  0DF1     RLF 0x271, F
16BE  35F0     LSLF 0x270, F
16BF  0DF1     RLF 0x271, F
16C0  30BB     MOVLW 0xBB
16C1  0770     ADDWF 0x270, W
16C2  0084     MOVWF FSR0L
16C3  3098     MOVLW 0x98
16C4  3D71     ADDWFC 0x271, W
16C5  0085     MOVWF FSR0H
16C6  0800     MOVF INDF0, W
16C7  00F2     MOVWF 0x272
16C8  0EF2     SWAPF 0x272, F
16C9  0DF2     RLF 0x272, F
16CA  0DF2     RLF 0x272, F
16CB  0021     MOVLB 0x1
16CC  080D     MOVF TRISB, W
16CD  0672     XORWF 0xF2, W
16CE  39BF     ANDLW 0xBF
16CF  0672     XORWF 0xF2, W
16D0  008D     MOVWF TRISB
62:                    return true;
16D1  3001     MOVLW 0x1
16D2  0008     RETURN
63:                }
64:                return false;
16D3  3000     MOVLW 0x0
65:            }
16D4  0008     RETURN
66:            
67:            // Full Duplex SPI Functions
68:            uint8_t spi_exchangeByte(uint8_t b)
69:            {
70:                SSP1BUF = b;
0005  0870     MOVF 0xF0, W
0006  0024     MOVLB 0x4
0007  0091     MOVWF SSP1BUF
71:                while(!PIR1bits.SSP1IF);
0008  0020     MOVLB 0x0
0009  1D90     BTFSS PIR1, 0x3
000A  2808     GOTO 0x8
72:                PIR1bits.SSP1IF = 0;
000B  1190     BCF PIR1, 0x3
73:                return SSP1BUF;
000C  0024     MOVLB 0x4
000D  0811     MOVF SSP1BUF, W
74:            }
000E  0008     RETURN
75:            
76:            void spi_exchangeBlock(void *block, size_t blockSize)
77:            {
78:                uint8_t *data = block;
79:                while(blockSize--)
80:                {
81:                    *data = spi_exchangeByte(*data );
82:                    data++;
83:                }
84:            }
85:            
86:            // Half Duplex SPI Functions
87:            void spi_writeBlock(void *block, size_t blockSize)
88:            {
89:                uint8_t *data = block;
90:                while(blockSize--)
91:                {
92:                    spi_exchangeByte(*data++);
93:                }
94:            }
95:            
96:            void spi_readBlock(void *block, size_t blockSize)
97:            {
98:                uint8_t *data = block;
99:                while(blockSize--)
100:               {
101:                   *data++ = spi_exchangeByte(0);
102:               }
103:           }
104:           
105:           void spi_writeByte(uint8_t byte){
106:               SSP1BUF = byte;
107:           }
108:           
109:           uint8_t spi_readByte(void){
110:               return SSP1BUF;
111:           }
112:           
113:           /**
114:            * Interrupt from MSSP on bit 8 received and SR moved to buffer
115:            * If interrupts are not being used, then call this method from the main while(1) loop
116:            */
117:           void spi_isr(void){
118:               if(PIR1bits.SSP1IF == 1){
119:                   if(spi_interruptHandler){
120:                       spi_interruptHandler();
121:                   }
122:                   PIR1bits.SSP1IF = 0;
123:               }
124:           }
125:           
126:           void spi_setSpiISR(void(*handler)(void)){
127:               spi_interruptHandler = handler;
128:           }
---  C:/Users/Raphael/Desktop/hx711_lib_simple.X/mcc_generated_files/pin_manager.c  ---------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC16F1619
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00
21:                    MPLAB             :  MPLAB X 5.10
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATA = 0x00;
13F0  0022     MOVLB 0x2
13F1  018C     CLRF LATA
61:                LATB = 0x00;
13F2  018D     CLRF LATB
62:                LATC = 0x00;
13F3  018E     CLRF LATC
63:            
64:                /**
65:                TRISx registers
66:                */
67:                TRISA = 0x33;
13F4  3033     MOVLW 0x33
13F5  0021     MOVLB 0x1
13F6  008C     MOVWF TRISA
68:                TRISB = 0xB0;
13F7  30B0     MOVLW 0xB0
13F8  008D     MOVWF TRISB
69:                TRISC = 0xFF;
13F9  30FF     MOVLW 0xFF
13FA  008E     MOVWF TRISC
70:            
71:                /**
72:                ANSELx registers
73:                */
74:                ANSELC = 0xCE;
13FB  30CE     MOVLW 0xCE
13FC  0023     MOVLB 0x3
13FD  008E     MOVWF ANSELC
75:                ANSELB = 0x80;
13FE  3080     MOVLW 0x80
13FF  008D     MOVWF ANSELB
76:                ANSELA = 0x13;
1400  3013     MOVLW 0x13
1401  008C     MOVWF ANSELA
77:            
78:                /**
79:                WPUx registers
80:                */
81:                WPUB = 0x00;
1402  0024     MOVLB 0x4
1403  018D     CLRF WPUB
82:                WPUA = 0x00;
1404  018C     CLRF WPUA
83:                WPUC = 0x00;
1405  018E     CLRF WPUC
84:                OPTION_REGbits.nWPUEN = 0;
1406  0021     MOVLB 0x1
1407  1395     BCF OPTION_REG, 0x7
85:            
86:                /**
87:                ODx registers
88:                */
89:                ODCONA = 0x00;
1408  0025     MOVLB 0x5
1409  018C     CLRF ODCONA
90:                ODCONB = 0x00;
140A  018D     CLRF ODCONB
91:                ODCONC = 0x00;
140B  018E     CLRF ODCONC
92:            
93:                /**
94:                SLRCONx registers
95:                */
96:                SLRCONA = 0x37;
140C  3037     MOVLW 0x37
140D  0026     MOVLB 0x6
140E  008C     MOVWF SLRCONA
97:                SLRCONB = 0xF0;
140F  30F0     MOVLW 0xF0
1410  008D     MOVWF SLRCONB
98:                SLRCONC = 0xFF;
1411  30FF     MOVLW 0xFF
1412  008E     MOVWF SLRCONC
99:            
100:           
101:           
102:           
103:           
104:              
105:               
106:           	
107:               RXPPS = 0x10;   //RC0->EUSART:RX;    
1413  3010     MOVLW 0x10
1414  003C     MOVLB 0x1C
1415  00A4     MOVWF RXPPS
108:               SSPDATPPS = 0x0D;   //RB5->MSSP:SDI;    
1416  300D     MOVLW 0xD
1417  00A1     MOVWF SSPDATPPS
109:               RB6PPS = 0x10;   //RB6->MSSP:SCK;    
1418  3010     MOVLW 0x10
1419  003D     MOVLB 0x1D
141A  009E     MOVWF RB6PPS
110:               RA2PPS = 0x12;   //RA2->EUSART:TX;    
141B  3012     MOVLW 0x12
141C  0092     MOVWF RA2PPS
111:               SSPCLKPPS = 0x0E;   //RB6->MSSP:SCK;    
141D  300E     MOVLW 0xE
141E  003C     MOVLB 0x1C
141F  00A0     MOVWF SSPCLKPPS
112:           }
1420  0008     RETURN
113:             
114:           void PIN_MANAGER_IOC(void)
115:           {   
116:           }
117:           
118:           /**
119:            End of File
120:           */
---  C:/Users/Raphael/Desktop/hx711_lib_simple.X/mcc_generated_files/mcc.c  -----------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC16F1619
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 or later
21:                    MPLAB             :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                PIN_MANAGER_Initialize();
12BF  3193     MOVLP 0x13
12C0  23F0     CALL 0x3F0
12C1  3192     MOVLP 0x12
53:                OSCILLATOR_Initialize();
12C2  3192     MOVLP 0x12
12C3  22A2     CALL 0x2A2
12C4  3192     MOVLP 0x12
54:                EUSART_Initialize();
12C5  3193     MOVLP 0x13
12C6  235A     CALL 0x35A
55:            }
12C7  0008     RETURN
56:            
57:            void OSCILLATOR_Initialize(void)
58:            {
59:                // SCS INTOSC; SPLLEN disabled; IRCF 16MHz_HF; 
60:                OSCCON = 0x7A;
12A2  307A     MOVLW 0x7A
12A3  0021     MOVLB 0x1
12A4  0099     MOVWF OSCCON
61:                // TUN 0; 
62:                OSCTUNE = 0x00;
12A5  0198     CLRF OSCTUNE
63:                // SBOREN disabled; BORFS disabled; 
64:                BORCON = 0x00;
12A6  0022     MOVLB 0x2
12A7  0196     CLRF BORCON
65:            }
12A8  0008     RETURN
66:            
67:            
68:            
69:            /**
70:             End of File
71:            */
---  C:/Users/Raphael/Desktop/hx711_lib_simple.X/mcc_generated_files/eusart.c  --------------------------
1:             /**
2:               EUSART Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 eusart.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the EUSART driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for EUSART.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC16F1619
18:                    Driver Version    :  2.1.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00
21:                    MPLAB 	          :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include "eusart.h"
51:            
52:            volatile eusart_status_t eusartRxLastError;
53:            
54:            /**
55:              Section: EUSART APIs
56:            */
57:            void (*EUSART_FramingErrorHandler)(void);
58:            void (*EUSART_OverrunErrorHandler)(void);
59:            void (*EUSART_ErrorHandler)(void);
60:            
61:            void EUSART_DefaultFramingErrorHandler(void);
62:            void EUSART_DefaultOverrunErrorHandler(void);
63:            void EUSART_DefaultErrorHandler(void);
64:            
65:            void EUSART_Initialize(void)
66:            {
67:                // Set the EUSART module to the options selected in the user interface.
68:            
69:                // ABDOVF no_overflow; SCKP Non-Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
70:                BAUD1CON = 0x08;
135A  3008     MOVLW 0x8
135B  0023     MOVLB 0x3
135C  009F     MOVWF BAUD1CON
71:            
72:                // SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
73:                RC1STA = 0x90;
135D  3090     MOVLW 0x90
135E  009D     MOVWF RC1STA
74:            
75:                // TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
76:                TX1STA = 0x24;
135F  3024     MOVLW 0x24
1360  009E     MOVWF TX1STA
77:            
78:                // SP1BRGL 34; 
79:                SPBRGL = 0x22;
1361  3022     MOVLW 0x22
1362  009B     MOVWF SP1BRG
80:            
81:                // SP1BRGH 0; 
82:                SPBRGH = 0x00;
1363  019C     CLRF SP1BRGH
83:            
84:            
85:                EUSART_SetFramingErrorHandler(EUSART_DefaultFramingErrorHandler);
1364  3000     MOVLW 0x0
1365  00F0     MOVWF 0x1F0
1366  3000     MOVLW 0x0
1367  00F1     MOVWF 0x1F1
1368  3192     MOVLP 0x12
1369  2295     CALL 0x295
136A  3193     MOVLP 0x13
86:                EUSART_SetOverrunErrorHandler(EUSART_DefaultOverrunErrorHandler);
136B  3000     MOVLW 0x0
136C  00F0     MOVWF 0x1F0
136D  3000     MOVLW 0x0
136E  00F1     MOVWF 0x1F1
136F  3192     MOVLP 0x12
1370  2290     CALL 0x290
1371  3193     MOVLP 0x13
87:                EUSART_SetErrorHandler(EUSART_DefaultErrorHandler);
1372  3000     MOVLW 0x0
1373  00F0     MOVWF 0x1F0
1374  3000     MOVLW 0x0
1375  00F1     MOVWF 0x1F1
1376  3192     MOVLP 0x12
1377  228B     CALL 0x28B
88:            
89:                eusartRxLastError.status = 0;
1378  01C6     CLRF 0x1C6
90:            
91:            }
1379  0008     RETURN
92:            
93:            bool EUSART_is_tx_ready(void)
94:            {
95:                return (bool)(PIR1bits.TXIF && TX1STAbits.TXEN);
96:            }
97:            
98:            bool EUSART_is_rx_ready(void)
99:            {
100:               return PIR1bits.RCIF;
101:           }
102:           
103:           bool EUSART_is_tx_done(void)
104:           {
105:               return TX1STAbits.TRMT;
106:           }
107:           
108:           eusart_status_t EUSART_get_last_status(void){
109:               return eusartRxLastError;
110:           }
111:           
112:           uint8_t EUSART_Read(void)
113:           {
114:               while(!PIR1bits.RCIF)
115:               {
116:               }
117:           
118:               eusartRxLastError.status = 0;
119:               
120:               if(1 == RC1STAbits.OERR)
121:               {
122:                   // EUSART error - restart
123:           
124:                   RC1STAbits.CREN = 0; 
125:                   RC1STAbits.CREN = 1; 
126:               }
127:           
128:               return RC1REG;
129:           }
130:           
131:           void EUSART_Write(uint8_t txData)
132:           {
133:               while(0 == PIR1bits.TXIF)
134:               {
135:               }
12A9  0020     MOVLB 0x0
12AA  1E10     BTFSS PIR1, 0x4
12AB  2AA9     GOTO 0x2A9
136:           
137:               TX1REG = txData;    // Write the data byte to the USART.
12AC  0870     MOVF __pcstackCOMMON, W
12AD  0023     MOVLB 0x3
12AE  009A     MOVWF TX1REG
138:           }
12AF  0008     RETURN
139:           
140:           char getch(void)
141:           {
142:               return EUSART_Read();
143:           }
144:           
145:           void putch(char txData)
146:           {
147:               EUSART_Write(txData);
12B0  0871     MOVF 0x1F1, W
12B1  00F2     MOVWF 0x1F2
12B2  0872     MOVF 0x1F2, W
12B3  00F0     MOVWF 0x1F0
12B4  3192     MOVLP 0x12
12B5  22A9     CALL 0x2A9
148:           }
12B6  0008     RETURN
149:           
150:           
151:           
152:           void EUSART_DefaultFramingErrorHandler(void){}
153:           
154:           void EUSART_DefaultOverrunErrorHandler(void){
155:               // EUSART error - restart
156:           
157:               RC1STAbits.CREN = 0;
158:               RC1STAbits.CREN = 1;
159:           
160:           }
161:           
162:           void EUSART_DefaultErrorHandler(void){
163:           }
164:           
165:           void EUSART_SetFramingErrorHandler(void (* interruptHandler)(void)){
166:               EUSART_FramingErrorHandler = interruptHandler;
1295  0871     MOVF 0x1F1, W
1296  0021     MOVLB 0x1
1297  00CC     MOVWF 0xCC
1298  0870     MOVF 0xF0, W
1299  00CB     MOVWF EUSART_FramingErrorHandler
167:           }
129A  0008     RETURN
168:           
169:           void EUSART_SetOverrunErrorHandler(void (* interruptHandler)(void)){
170:               EUSART_OverrunErrorHandler = interruptHandler;
1290  0871     MOVF 0xF1, W
1291  00CA     MOVWF 0xCA
1292  0870     MOVF 0xF0, W
1293  00C9     MOVWF EUSART_OverrunErrorHandler
171:           }
1294  0008     RETURN
172:           
173:           void EUSART_SetErrorHandler(void (* interruptHandler)(void)){
174:               EUSART_ErrorHandler = interruptHandler;
128B  0871     MOVF 0xF1, W
128C  00C8     MOVWF 0xC8
128D  0870     MOVF 0xF0, W
128E  00C7     MOVWF EUSART_ErrorHandler
175:           }
128F  0008     RETURN
176:           
177:           
178:           /**
179:             End of File
180:           */
---  C:/Users/Raphael/Desktop/hx711_lib_simple.X/main.c  ------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC16F1619
18:                    Driver Version    :  2.00
19:            */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:            */
43:            
44:            #include <stdlib.h>
45:            #include <stdint.h>
46:            #include <stdio.h>
47:            
48:            #include "mcc_generated_files/mcc.h"
49:            #include "hx711.h"
50:            
51:            #define calibration_factor -7050.0
52:            
53:            /*
54:                                     Main application
55:             */
56:            void main(void)
57:            {
58:                uint8_t aux[50];
59:                
60:                float valor = 0;
61:                
62:                // initialize the device
63:                SYSTEM_Initialize();
1532  3192     MOVLP 0x12
1533  22BF     CALL 0x2BF
1534  3195     MOVLP 0x15
64:                spi_open(SPI_DEFAULT);
1535  3001     MOVLW 0x1
1536  3196     MOVLP 0x16
1537  267D     CALL 0x67D
1538  3195     MOVLP 0x15
65:                
66:                //HX711_set_gain(128);
67:            
68:                // When using interrupts, you need to set the Global and Peripheral Interrupt Enable bits
69:                // Use the following macros to:
70:            
71:                // Enable the Global Interrupts
72:                //INTERRUPT_GlobalInterruptEnable();
73:            
74:                // Enable the Peripheral Interrupts
75:                //INTERRUPT_PeripheralInterruptEnable();
76:            
77:                // Disable the Global Interrupts
78:                //INTERRUPT_GlobalInterruptDisable();
79:            
80:                // Disable the Peripheral Interrupts
81:                //INTERRUPT_PeripheralInterruptDisable();
82:                
83:                //HX711_set_scale(calibration_factor);
84:                ///HX711_tare(1);
85:                
86:                while (1)
87:                {
88:                    if(HX711_is_ready())
1539  3192     MOVLP 0x12
153A  229B     CALL 0x29B
153B  3195     MOVLP 0x15
153C  3A00     XORLW 0x0
153D  1903     BTFSC STATUS, 0x2
153E  2D6E     GOTO 0x56E
89:                    {
90:                        float reading = HX711_read_average(2);
153F  3002     MOVLW 0x2
1540  3194     MOVLP 0x14
1541  24E3     CALL 0x4E3
1542  3195     MOVLP 0x15
1543  0856     MOVF 0xD6, W
1544  0022     MOVLB 0x2
1545  00D5     MOVWF reading
1546  0020     MOVLB 0x0
1547  0857     MOVF 0x57, W
1548  0022     MOVLB 0x2
1549  00D6     MOVWF 0x156
154A  0020     MOVLB 0x0
154B  0858     MOVF 0x58, W
154C  0022     MOVLB 0x2
154D  00D7     MOVWF 0x157
91:                        printf("HX711 reading: ");
154E  309C     MOVLW 0x9C
154F  0020     MOVLB 0x0
1550  00E5     MOVWF f
1551  3098     MOVLW 0x98
1552  00E6     MOVWF 0x66
1553  3192     MOVLP 0x12
1554  22D6     CALL 0x2D6
1555  3195     MOVLP 0x15
92:                        sprintf(aux, "%f \n", reading);
1556  30CF     MOVLW 0xCF
1557  00E5     MOVWF f
1558  3098     MOVLW 0x98
1559  00E6     MOVWF 0x66
155A  0022     MOVLB 0x2
155B  0855     MOVF reading, W
155C  0020     MOVLB 0x0
155D  00E7     MOVWF 0x67
155E  0022     MOVLB 0x2
155F  0856     MOVF 0x156, W
1560  0020     MOVLB 0x0
1561  00E8     MOVWF ap
1562  0022     MOVLB 0x2
1563  0857     MOVF 0x157, W
1564  0020     MOVLB 0x0
1565  00E9     MOVWF pb
1566  3020     MOVLW 0x20
1567  3188     MOVLP 0x8
1568  2000     CALL 0x0
1569  3195     MOVLP 0x15
93:                        printf(aux);
156A  3020     MOVLW 0x20
156B  00E5     MOVWF f
156C  3001     MOVLW 0x1
156D  2D71     GOTO 0x571
94:                    }
95:                    else
96:                    {
97:                        printf("HX711 not found.\n");
156E  308A     MOVLW 0x8A
156F  00E5     MOVWF f
1570  3098     MOVLW 0x98
1571  00E6     MOVWF 0x66
1572  3192     MOVLP 0x12
1573  22D6     CALL 0x2D6
1574  3195     MOVLP 0x15
98:                    }
99:            
100:                   __delay_ms(50);
1575  3002     MOVLW 0x2
1576  0021     MOVLB 0x1
1577  00BC     MOVWF 0xBC
1578  3004     MOVLW 0x4
1579  00BB     MOVWF 0xBB
157A  30BA     MOVLW 0xBA
157B  0B89     DECFSZ WREG, F
157C  2D7B     GOTO 0x57B
157D  0BBB     DECFSZ 0xBB, F
157E  2D7B     GOTO 0x57B
157F  0BBC     DECFSZ 0xBC, F
1580  2D7B     GOTO 0x57B
1581  0000     NOP
1582  2D39     GOTO 0x539
101:               }
102:           }
103:           /**
104:            End of File
105:           */
---  C:/Users/Raphael/Desktop/hx711_lib_simple.X/hx711.c  -----------------------------------------------
1:             /* 
2:              * File:   hx711.c
3:              * Author: Raphael
4:              *
5:              * Created on June 2, 2019, 9:16 PM
6:              */
7:             
8:             #include "hx711.h"
9:             #include "mcc_generated_files/device_config.h"
10:            #include "mcc_generated_files/spi_driver.h"
11:            
12:            void HX711_begin(uint8_t dout, uint8_t pd_sck, uint8_t gain)
13:            {
14:                //PD_SCK = pd_sck;
15:                //DOUT = dout;
16:            
17:                sckTris = 0;
18:                doutTris = 1;
19:            
20:                HX711_set_gain(gain);
21:            }
22:            
23:            bool HX711_is_ready()
24:            {
25:                return (!doutPin); //digitalRead(DOUT) == LOW;
129B  1003     BCF STATUS, 0x0
129C  0020     MOVLB 0x0
129D  1E0D     BTFSS PORTB, 0x4
129E  1403     BSF STATUS, 0x0
129F  3000     MOVLW 0x0
12A0  3D09     ADDWFC WREG, W
26:            }
12A1  0008     RETURN
27:            
28:            void HX711_set_gain(uint8_t gain)
29:            {
30:                switch(gain)
31:                {
32:                    case 128: // channel A, gain factor 128
33:                        GAIN = 1;
34:                        break;
35:                    case 64: // channel A, gain factor 64
36:                        GAIN = 3;
37:                        break;
38:                    case 32: // channel B, gain factor 32
39:                        GAIN = 2;
40:                        break;
41:                }
42:            
43:                sckLat = 0;
44:                HX711_read();
45:            }
46:            
47:            int32_t HX711_read_new()
48:            {
49:                // Define structures for reading data into.
50:                int32_t value = 0;
51:                uint8_t data[3] = {0};
52:                uint8_t filler = 0;
53:                
54:                // Wait for the chip to become ready.
55:                while(doutPin);
56:                
57:                __delay_us(10);
58:                
59:                // Pulse the clock pin 24 times to read the data.
60:                data[2] = spi_exchangeByte(0); //SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);
61:                data[1] = spi_exchangeByte(0); //SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);
62:                data[0] = spi_exchangeByte(0); //SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);
63:            
64:                // Set the channel and the gain factor for the next reading using the clock pin.
65:                for(unsigned int i = 0; i < GAIN; i++)
66:                {
67:                    sckPin = 1;
68:                    __delay_us(1);
69:                    sckPin = 0;
70:                    __delay_us(1);
71:                }
72:            
73:                // Replicate the most significant bit to pad out a 32-bit signed integer
74:                if(data[2] & 0x80)
75:                {
76:                    filler = 0xFF;
77:                }
78:                else
79:                {
80:                    filler = 0x00;
81:                }
82:            
83:                // Construct a 32-bit signed integer
84:                value = ((uint32_t)(filler) << 24
85:                        | (uint32_t)(data[2]) << 16
86:                        | (uint32_t)(data[1]) << 8
87:                        | (uint32_t)(data[0]));
88:                
89:                printf("%03i  ", data[2]);
90:                printf("%03i  ", data[1]);
91:                printf("%03i  \n", data[0]);
92:            
93:                return (value);
94:            }
95:            
96:            int32_t HX711_read()
97:            {
98:                int32_t value_32aux;
99:            
100:               union charto32bits
101:               {
102:                   uint32_t value_32;
103:                   uint8_t value_8[3];
104:               } value;
105:               
106:               // Wait for the chip to become ready.
107:               while(doutPin);
1627  1A0D     BTFSC PORTB, 0x4
1628  2E27     GOTO 0x627
108:           
109:               __delay_us(1);
1629  3200     BRA 0x162A
162A  3200     BRA 0x162B
110:           
111:               // Pulse the clock pin 24 times to read the data.
112:               value.value_8[2] = spi_exchangeByte(0);
162B  01F0     CLRF __pcstackCOMMON
162C  3180     MOVLP 0x0
162D  2005     CALL 0x5
162E  3196     MOVLP 0x16
162F  00F5     MOVWF rem
1630  0875     MOVF rem, W
1631  0020     MOVLB 0x0
1632  00A8     MOVWF f1
113:               value.value_8[1] = spi_exchangeByte(0);
1633  01F0     CLRF __pcstackCOMMON
1634  3180     MOVLP 0x0
1635  2005     CALL 0x5
1636  3196     MOVLP 0x16
1637  00F5     MOVWF rem
1638  0875     MOVF rem, W
1639  0020     MOVLB 0x0
163A  00A7     MOVWF f1
114:               value.value_8[0] = spi_exchangeByte(0);
163B  01F0     CLRF __pcstackCOMMON
163C  3180     MOVLP 0x0
163D  2005     CALL 0x5
163E  3196     MOVLP 0x16
163F  00F5     MOVWF rem
1640  0875     MOVF rem, W
1641  0020     MOVLB 0x0
1642  00A6     MOVWF multiplicand
115:           
116:               // Set the channel and the gain factor for the next reading using the clock pin.
117:               for(uint16_t i = 0; i < GAIN; i++)
1643  01A4     CLRF multiplier
1644  01A5     CLRF exp1
1645  3000     MOVLW 0x0
1646  0225     SUBWF exp1, W
1647  3003     MOVLW 0x3
1648  1903     BTFSC STATUS, 0x2
1649  0224     SUBWF multiplier, W
164A  1803     BTFSC STATUS, 0x0
164B  2E5A     GOTO 0x65A
1654  3001     MOVLW 0x1
1655  0020     MOVLB 0x0
1656  07A4     ADDWF multiplier, F
1657  3000     MOVLW 0x0
1658  3DA5     ADDWFC exp1, F
1659  2E45     GOTO 0x645
118:               {
119:                   sckLat = 1;
164C  0022     MOVLB 0x2
164D  170D     BSF LATB, 0x6
120:                   __delay_us(1);
164E  3200     BRA 0x164F
164F  3200     BRA 0x1650
121:                   sckLat = 0;
1650  0022     MOVLB 0x2
1651  130D     BCF LATB, 0x6
122:                   __delay_us(1);
1652  3200     BRA 0x1653
1653  3200     BRA 0x1654
123:               }
124:               
125:               // Replicate the most significant bit to pad out a 32-bit signed integer
126:               if(value.value_8[2] & 0x80)
165A  1FA8     BTFSS 0x128, 0x7
165B  2E6C     GOTO 0x66C
127:               {
128:                   value_32aux = value.value_32 * (-1);
165C  0926     COMF 0x126, W
165D  00A0     MOVWF __pcstackBANK2
165E  0927     COMF 0x127, W
165F  00A1     MOVWF 0x121
1660  0928     COMF 0x128, W
1661  00A2     MOVWF 0x122
1662  0929     COMF 0x129, W
1663  00A3     MOVWF 0x123
1664  0AA0     INCF __pcstackBANK2, F
1665  1903     BTFSC STATUS, 0x2
1666  0AA1     INCF 0x121, F
1667  1903     BTFSC STATUS, 0x2
1668  0AA2     INCF 0x122, F
1669  1903     BTFSC STATUS, 0x2
166A  0AA3     INCF 0x123, F
129:               }
166B  2E74     GOTO 0x674
130:               else
131:               {
132:                   value_32aux = value.value_32;
166C  0829     MOVF 0x129, W
166D  00A3     MOVWF 0x123
166E  0828     MOVF 0x128, W
166F  00A2     MOVWF 0x122
1670  0827     MOVF 0x127, W
1671  00A1     MOVWF 0x121
1672  0826     MOVF 0x126, W
1673  00A0     MOVWF __pcstackBANK2
133:               }
134:           
135:               return value_32aux;
1674  0823     MOVF 0x123, W
1675  00F4     MOVWF 0x174
1676  0822     MOVF 0x122, W
1677  00F3     MOVWF 0x173
1678  0821     MOVF 0x121, W
1679  00F2     MOVWF 0x172
167A  0820     MOVF __pcstackBANK2, W
167B  00F1     MOVWF 0x171
136:           }
167C  0008     RETURN
137:           
138:           void HX711_wait_ready(uint32_t time)
139:           {
140:               // Wait for the chip to become ready.
141:               // This is a blocking implementation and will
142:               // halt the sketch until a load cell is connected.
143:               while(!HX711_is_ready())
144:               {
145:                   // Probably will do no harm on AVR but will feed the Watchdog Timer (WDT) on ESP.
146:                   // https://github.com/bogde/HX711/issues/73
147:                   //__delay_ms(time);
148:               }
149:           }
150:           
151:           bool HX711_wait_ready_retry(int16_t retries, uint32_t time)
152:           {
153:               // Wait for the chip to become ready by
154:               // retrying for a specified amount of attempts.
155:               // https://github.com/bogde/HX711/issues/76
156:               int count = 0;
157:               while(count < retries)
158:               {
159:                   if(HX711_is_ready())
160:                   {
161:                       return true;
162:                   }
163:                   //__delay_ms(time);
164:                   count++;
165:               }
166:               return false;
167:           }
168:           
169:           bool HX711_wait_ready_timeout(uint32_t timeout, uint32_t time)
170:           {
171:               // Wait for the chip to become ready until timeout.
172:               // https://github.com/bogde/HX711/pull/96
173:               //unsigned long millisStarted = millis();
174:               /*while(millis() - millisStarted < timeout)
175:               {
176:                   if(HX711_is_ready())
177:                   {
178:                       return true;
179:                   }
180:                   __delay_ms(time);
181:               }*/
182:               return false;
183:           }
184:           
185:           float HX711_read_average(uint8_t times)
14E3  00DB     MOVWF 0x15B
186:           {
187:               float sum = 0;
14E4  3000     MOVLW 0x0
14E5  00DC     MOVWF 0x15C
14E6  3000     MOVLW 0x0
14E7  00DD     MOVWF 0x15D
14E8  3000     MOVLW 0x0
14E9  00DE     MOVWF 0x15E
188:               
189:               for(uint8_t i = 0; i < times; i++)
14EA  01DA     CLRF 0x15A
14EB  085B     MOVF 0x15B, W
14EC  025A     SUBWF 0x15A, W
14ED  1803     BTFSC STATUS, 0x0
14EE  2D18     GOTO 0x518
1513  3001     MOVLW 0x1
1514  00D9     MOVWF 0x159
1515  0859     MOVF 0x159, W
1516  07DA     ADDWF 0x15A, F
1517  2CEB     GOTO 0x4EB
190:               {
191:                   sum += HX711_read();
14EF  3196     MOVLP 0x16
14F0  2627     CALL 0x627
14F1  3194     MOVLP 0x14
14F2  0874     MOVF 0x174, W
14F3  00FB     MOVWF 0x17B
14F4  0873     MOVF 0x173, W
14F5  00FA     MOVWF 0x17A
14F6  0872     MOVF 0x172, W
14F7  00F9     MOVWF 0x179
14F8  0871     MOVF 0x171, W
14F9  00F8     MOVWF 0x178
14FA  3194     MOVLP 0x14
14FB  2421     CALL 0x421
14FC  3194     MOVLP 0x14
14FD  0878     MOVF 0x178, W
14FE  0020     MOVLB 0x0
14FF  00C9     MOVWF f1
1500  0879     MOVF counter, W
1501  00CA     MOVWF 0x4A
1502  087A     MOVF quotient, W
1503  00CB     MOVWF sign1
1504  085C     MOVF f, W
1505  00CC     MOVWF lval
1506  085D     MOVF 0x5D, W
1507  00CD     MOVWF 0x4D
1508  085E     MOVF ap, W
1509  00CE     MOVWF 0x4E
150A  3189     MOVLP 0x9
150B  211C     CALL 0x11C
150C  3194     MOVLP 0x14
150D  0849     MOVF f1, W
150E  00DC     MOVWF f
150F  084A     MOVF 0x4A, W
1510  00DD     MOVWF 0x5D
1511  084B     MOVF sign1, W
1512  00DE     MOVWF ap
192:                   // Probably will do no harm on AVR but will feed the Watchdog Timer (WDT) on ESP.
193:                   // https://github.com/bogde/HX711/issues/73
194:                   //__delay_ms(10);
195:               }
196:               return (sum / times);
1518  085B     MOVF times, W
1519  3192     MOVLP 0x12
151A  22EB     CALL 0x2EB
151B  3194     MOVLP 0x14
151C  0878     MOVF c, W
151D  0020     MOVLB 0x0
151E  00A4     MOVWF multiplier
151F  0879     MOVF counter, W
1520  00A5     MOVWF exp1
1521  087A     MOVF quotient, W
1522  00A6     MOVWF multiplicand
1523  085C     MOVF f, W
1524  00A7     MOVWF f1
1525  085D     MOVF 0x5D, W
1526  00A8     MOVWF f1
1527  085E     MOVF ap, W
1528  00A9     MOVWF counter
1529  3196     MOVLP 0x16
152A  26D5     CALL 0x6D5
152B  0824     MOVF multiplier, W
152C  00D6     MOVWF f2
152D  0825     MOVF exp1, W
152E  00D7     MOVWF 0x57
152F  0826     MOVF multiplicand, W
1530  00D8     MOVWF 0x58
197:           }
1531  0008     RETURN
198:           
199:           double HX711_get_value(uint8_t times)
200:           {
201:               return HX711_read_average(times) - OFFSET;
202:           }
203:           
204:           float HX711_get_units(uint8_t times)
205:           {
206:               return HX711_get_value(times) / SCALE;
207:           }
208:           
209:           void HX711_tare(uint8_t times)
210:           {
211:               double sum = HX711_read_average(times);
212:               HX711_set_offset(sum);
213:           }
214:           
215:           void HX711_set_scale(float scale)
216:           {
217:               SCALE = scale;
218:           }
219:           
220:           float HX711_get_scale()
221:           {
222:               return SCALE;
223:           }
224:           
225:           void HX711_set_offset(int32_t offset)
226:           {
227:               OFFSET = offset;
228:           }
229:           
230:           int32_t HX711_get_offset()
231:           {
232:               return OFFSET;
233:           }
234:           
235:           void HX711_power_down()
236:           {
237:               sckLat = 0;
238:               sckLat = 1;
239:           }
240:           
241:           void HX711_power_up()
242:           {
243:               sckLat = 0;
244:           }
245:           
246:           uint8_t shiftIn(uint8_t bitOrder)
247:           {
248:           
249:               uint8_t value = 0;
250:           
251:               uint8_t i;
252:           
253:               for(i = 0; i < 8; ++i)
254:               {
255:           
256:                   sckLat = 1;
257:           
258:                   if(bitOrder == LSBFIRST)
259:           
260:                       value |= doutPin << i;
261:           
262:                   else
263:           
264:                       value |= doutPin << (7 - i);
265:           
266:                   sckLat = 0;
267:           
268:               }
269:           
270:               return value;
271:           
272:           }
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/sprintf.c  -----------------------
1:             #include	<stdio.h>
2:             #include	<stdarg.h>
3:             
4:             #if	defined(_MPC_) && !defined(_OMNI_CODE_) && !defined(__DSPICC__)
5:             sprintf(char * wh, const char * f, ...)
6:             {
7:             	va_list	ap;
8:             
9:             	va_start(ap, f);
10:            	_doprnt(wh, f, ap);
11:            }
12:            #else
13:            sprintf(char * wh, const char * f, ...)
0800  00EB     MOVWF wh
14:            {
15:            #ifdef	_HOSTED
16:            	FILE	spf;
17:            	va_list	ap;
18:            
19:            	va_start(ap, f);
20:            	spf._size = 32767;
21:            	spf._cnt = 0;
22:            	spf._base = spf._ptr = wh;
23:            	spf._flag = _IOWRT|_IOBINARY|_IOSTRG;
24:            	vfprintf(&spf, f, ap);
25:            	*spf._ptr = 0;
26:            	return spf._ptr - wh;
27:            #else
28:            	va_list	ap;
29:            	struct	__prbuf	pb;
30:            	
31:            	pb.ptr = wh;
0801  086B     MOVF wh, W
0802  00EA     MOVWF 0x6A
0803  086A     MOVF 0x6A, W
0804  00ED     MOVWF pb
32:            	pb.func = (void (*)(char))NULL;
0805  01EE     CLRF 0x6E
0806  01EF     CLRF 0x6F
33:            	va_start(ap, f);
0807  3067     MOVLW 0x67
0808  00EA     MOVWF 0x6A
0809  086A     MOVF 0x6A, W
080A  00EC     MOVWF ap
34:            	_doprnt(&pb, f, ap);
080B  0866     MOVF 0x66, W
080C  00DD     MOVWF 0x5D
080D  0865     MOVF f, W
080E  00DC     MOVWF f
080F  306C     MOVLW 0x6C
0810  00EA     MOVWF 0x6A
0811  086A     MOVF 0x6A, W
0812  00DE     MOVWF ap
0813  306D     MOVLW 0x6D
0814  3182     MOVLP 0x2
0815  22C4     CALL 0x2C4
35:            	*pb.ptr = 0;
0816  086D     MOVF pb, W
0817  0086     MOVWF FSR1
0818  3001     MOVLW 0x1
0819  0087     MOVWF FSR1H
081A  0181     CLRF INDF1
36:            	return pb.ptr - wh;
37:            #endif
38:            }
081B  0008     RETURN
39:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/printf.c  ------------------------
1:             #include	<stdio.h>
2:             #include	<stdarg.h>
3:             
4:             #if	defined(_MPC_) && !defined(_OMNI_CODE_) && !defined(__DSPICC__)
5:             printf(const char * f, ...)
6:             {
7:             	va_list	ap;
8:             
9:             	va_start(ap, f);
10:            	_doprnt(0, f, ap);
11:            }
12:            #else
13:            printf(const char * f, ...)
14:            {
15:            	va_list	ap;
16:            
17:            #ifdef	_HOSTED
18:            	va_start(ap, f);
19:            	return(vfprintf(stdout, f, ap));
20:            #else
21:            	struct	__prbuf	pb;
22:            
23:            	pb.ptr = 0;
12D6  01E9     CLRF pb
24:            	pb.func = putch;
12D7  30B0     MOVLW 0xB0
12D8  00EA     MOVWF 0x6A
12D9  3012     MOVLW 0x12
12DA  00EB     MOVWF wh
25:            	va_start(ap, f);
12DB  3067     MOVLW 0x67
12DC  00E7     MOVWF 0x67
12DD  0867     MOVF 0x67, W
12DE  00E8     MOVWF ap
26:            	return _doprnt(&pb, f, ap);
12DF  0866     MOVF 0x66, W
12E0  00DD     MOVWF 0x5D
12E1  0865     MOVF f, W
12E2  00DC     MOVWF f
12E3  3068     MOVLW 0x68
12E4  00E7     MOVWF 0x67
12E5  0867     MOVF 0x67, W
12E6  00DE     MOVWF ap
12E7  3069     MOVLW 0x69
12E8  3182     MOVLP 0x2
12E9  22C4     CALL 0x2C4
27:            #endif
28:            }
12EA  0008     RETURN
29:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/lltoft.c  ------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned long int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(__uint24 *)&f1)
15:            float
16:            __lltoft(unsigned long int c)
17:            {
18:            	float	f1;
19:            	unsigned char	exp;
20:            	
21:            	if(c == 0)
22:            		return 0.0;
23:            	exp = 127+15;
24:            	// normalize 32 bits to 24 first
25:            	while(c & ~0xFFFFFFUL) {
26:            		c >>= 1;
27:            		exp++;
28:            	}
29:            	f1_as_mant1 = c;
30:            	__ftpack(&f1_as_mant1, exp);
31:            	return f1;
32:            }
33:            #else
34:            float
35:            __lltoft(unsigned long int c)
36:            {
37:            	unsigned char	exp;
38:            	exp = 127+15;
139B  308E     MOVLW 0x8E
139C  00FC     MOVWF product
139D  087C     MOVF product, W
139E  00FD     MOVWF exp
39:            
40:            	// normalize 32 bits to 24 first
41:            	while(c & ~0xFFFFFFUL) {
139F  30FF     MOVLW 0xFF
13A0  057B     ANDWF c, W
13A1  1903     BTFSC STATUS, 0x2
13A2  2BAF     GOTO 0x3AF
13AE  2B9F     GOTO 0x39F
42:            		c >>= 1;
13A3  3001     MOVLW 0x1
13A4  36FB     LSRF c, F
13A5  0CFA     RRF quotient, F
13A6  0CF9     RRF counter, F
13A7  0CF8     RRF c, F
13A8  0B89     DECFSZ WREG, F
13A9  2BA4     GOTO 0x3A4
43:            		exp++;
13AA  3001     MOVLW 0x1
13AB  00FC     MOVWF product
13AC  087C     MOVF product, W
13AD  07FD     ADDWF exp, F
44:            	}
45:            	return __ftpack((__uint24)c, exp, 0);
13AF  0878     MOVF c, W
13B0  00F0     MOVWF __pcstackCOMMON
13B1  0879     MOVF counter, W
13B2  00F1     MOVWF c
13B3  087A     MOVF quotient, W
13B4  00F2     MOVWF dividend
13B5  087D     MOVF exp, W
13B6  00FC     MOVWF product
13B7  087C     MOVF product, W
13B8  00F3     MOVWF exp
13B9  01F4     CLRF sign
13BA  3188     MOVLP 0x8
13BB  201C     CALL 0x1C
13BC  0870     MOVF __pcstackCOMMON, W
13BD  00F8     MOVWF c
13BE  0871     MOVF c, W
13BF  00F9     MOVWF counter
13C0  0872     MOVF dividend, W
13C1  00FA     MOVWF quotient
46:            }
13C2  0008     RETURN
47:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/llmod.c  -------------------------
1:             // long unsigned unsigned modulus
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             __llmod(unsigned long int divisor, unsigned long int dividend)
6:             #else
7:             __llmod(unsigned long int dividend, unsigned long int divisor)
8:             #endif
9:             {
10:            	unsigned char	counter;
11:            
12:            	if(divisor != 0) {
145C  0823     MOVF 0x23, W
145D  0422     IORWF quotient, W
145E  0421     IORWF sign, W
145F  0420     IORWF __pcstackBANK0, W
1460  1903     BTFSC STATUS, 0x2
1461  2C95     GOTO 0x495
13:            		counter = 1;
1462  01A9     CLRF counter
1463  0AA9     INCF counter, F
14:            		while((divisor & 0x80000000UL) == 0) {
1464  1BA3     BTFSC 0x23, 0x7
1465  2C72     GOTO 0x472
1471  2C64     GOTO 0x464
15:            			divisor <<= 1;
1466  3001     MOVLW 0x1
1467  35A0     LSLF __pcstackBANK0, F
1468  0DA1     RLF sign, F
1469  0DA2     RLF quotient, F
146A  0DA3     RLF 0x23, F
146B  0B89     DECFSZ WREG, F
146C  2C67     GOTO 0x467
16:            			counter++;
146D  3001     MOVLW 0x1
146E  00A8     MOVWF f1
146F  0828     MOVF f1, W
1470  07A9     ADDWF counter, F
17:            		}
18:            		do {
19:            			if((unsigned long)divisor <= (unsigned long)dividend)
1472  0823     MOVF 0x23, W
1473  0227     SUBWF f1, W
1474  1D03     BTFSS STATUS, 0x2
1475  2C80     GOTO 0x480
1476  0822     MOVF quotient, W
1477  0226     SUBWF multiplicand, W
1478  1D03     BTFSS STATUS, 0x2
1479  2C80     GOTO 0x480
147A  0821     MOVF sign, W
147B  0225     SUBWF exp1, W
147C  1D03     BTFSS STATUS, 0x2
147D  2C80     GOTO 0x480
147E  0820     MOVF __pcstackBANK0, W
147F  0224     SUBWF multiplier, W
1480  1C03     BTFSS STATUS, 0x0
1481  2C8A     GOTO 0x48A
20:            				dividend -= divisor;
1482  0820     MOVF __pcstackBANK0, W
1483  02A4     SUBWF multiplier, F
1484  0821     MOVF sign, W
1485  3BA5     SUBWFB exp1, F
1486  0822     MOVF quotient, W
1487  3BA6     SUBWFB multiplicand, F
1488  0823     MOVF 0x23, W
1489  3BA7     SUBWFB f1, F
21:            			*(unsigned long int *)&divisor >>= 1;
148A  3001     MOVLW 0x1
148B  36A3     LSRF 0x23, F
148C  0CA2     RRF quotient, F
148D  0CA1     RRF sign, F
148E  0CA0     RRF __pcstackBANK0, F
148F  0B89     DECFSZ WREG, F
1490  2C8B     GOTO 0x48B
22:            		} while(--counter != 0);
1491  3001     MOVLW 0x1
1492  02A9     SUBWF counter, F
1493  1D03     BTFSS STATUS, 0x2
1494  2C72     GOTO 0x472
23:            	}
24:            	return dividend;
1495  0827     MOVF f1, W
1496  00A3     MOVWF 0x23
1497  0826     MOVF multiplicand, W
1498  00A2     MOVWF quotient
1499  0825     MOVF exp1, W
149A  00A1     MOVWF sign
149B  0824     MOVF multiplier, W
149C  00A0     MOVWF __pcstackBANK0
25:            }
149D  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/lbtoft.c  ------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert byte to float
12:            #ifdef _OLDLIB
13:            #define	f1_as_mant1	(*(__uint24 *)&f1)
14:            float
15:            __lbtoft(unsigned char c)
16:            {
17:            	float	f1;
18:            	
19:            	if(c == 0)
20:            		return 0.0;
21:            	f1_as_mant1 = c;
22:            	__ftpack(&f1_as_mant1, 127+15);
23:            	return f1;
24:            }
25:            #else
26:            float
27:            __lbtoft(unsigned char c)
12EB  00FB     MOVWF c
28:            {
29:            	return __ftpack(c, 127+15, 0);
12EC  087B     MOVF c, W
12ED  00A0     MOVWF __pcstackBANK0
12EE  01A1     CLRF sign
12EF  01A2     CLRF quotient
12F0  0820     MOVF __pcstackBANK0, W
12F1  00F0     MOVWF __pcstackCOMMON
12F2  0821     MOVF sign, W
12F3  00F1     MOVWF c
12F4  0822     MOVF quotient, W
12F5  00F2     MOVWF dividend
12F6  308E     MOVLW 0x8E
12F7  00A3     MOVWF 0x23
12F8  0823     MOVF 0x23, W
12F9  00F3     MOVWF exp
12FA  01F4     CLRF sign
12FB  3188     MOVLP 0x8
12FC  201C     CALL 0x1C
12FD  0870     MOVF __pcstackCOMMON, W
12FE  00F8     MOVWF c
12FF  0871     MOVF c, W
1300  00F9     MOVWF counter
1301  0872     MOVF dividend, W
1302  00FA     MOVWF quotient
30:            }
1303  0008     RETURN
31:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/lbmod.c  -------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
133B  00F3     MOVWF exp
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
133C  3008     MOVLW 0x8
133D  00F1     MOVWF c
133E  0871     MOVF c, W
133F  00F4     MOVWF sign
10:            	rem = 0;
1340  01F5     CLRF rem
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
1341  0873     MOVF exp, W
1342  00F1     MOVWF c
1343  3007     MOVLW 0x7
1344  36F1     LSRF c, F
1345  0B89     DECFSZ WREG, F
1346  2B44     GOTO 0x344
1347  3575     LSLF rem, W
1348  0471     IORWF c, W
1349  00F2     MOVWF dividend
134A  0872     MOVF dividend, W
134B  00F5     MOVWF rem
13:            		dividend <<= 1;
134C  1003     BCF STATUS, 0x0
134D  0DF3     RLF exp, F
14:            		if(divisor <= rem)
134E  0870     MOVF __pcstackCOMMON, W
134F  0275     SUBWF rem, W
1350  1C03     BTFSS STATUS, 0x0
1351  2B54     GOTO 0x354
15:            			rem -= divisor;
1352  0870     MOVF __pcstackCOMMON, W
1353  02F5     SUBWF rem, F
16:            	} while(--counter != 0);
1354  3001     MOVLW 0x1
1355  02F4     SUBWF sign, F
1356  1D03     BTFSS STATUS, 0x2
1357  2B41     GOTO 0x341
17:            	return rem;
1358  0875     MOVF rem, W
18:            }
1359  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/lbdiv.c  -------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
137A  00F8     MOVWF c
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
137B  01FA     CLRF quotient
10:            	if(divisor != 0) {
137C  0876     MOVF divisor, W
137D  1903     BTFSC STATUS, 0x2
137E  2B99     GOTO 0x399
11:            		counter = 1;
137F  01F9     CLRF counter
1380  0AF9     INCF counter, F
12:            		while((divisor & 0x80) == 0) {
1381  1BF6     BTFSC divisor, 0x7
1382  2B8A     GOTO 0x38A
1389  2B81     GOTO 0x381
13:            			divisor <<= 1;
1383  1003     BCF STATUS, 0x0
1384  0DF6     RLF divisor, F
14:            			counter++;
1385  3001     MOVLW 0x1
1386  00F7     MOVWF divisor
1387  0877     MOVF divisor, W
1388  07F9     ADDWF counter, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
138A  1003     BCF STATUS, 0x0
138B  0DFA     RLF quotient, F
18:            			if(divisor <= dividend) {
138C  0876     MOVF divisor, W
138D  0278     SUBWF c, W
138E  1C03     BTFSS STATUS, 0x0
138F  2B94     GOTO 0x394
19:            				dividend -= divisor;
1390  0876     MOVF divisor, W
1391  02F8     SUBWF c, F
20:            				quotient |= 1;
1392  147A     BSF quotient, 0x0
21:            			}
22:            			divisor >>= 1;
1393  1003     BCF STATUS, 0x0
1394  0CF6     RRF divisor, F
23:            		} while(--counter != 0);
1395  3001     MOVLW 0x1
1396  02F9     SUBWF counter, F
1397  1D03     BTFSS STATUS, 0x2
1398  2B8A     GOTO 0x38A
24:            	}
25:            	return quotient;
1399  087A     MOVF quotient, W
26:            }
139A  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/isdigit.c  -----------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             __bit
8:             isdigit(char c)
12C8  00F1     MOVWF c
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
12C9  01F0     CLRF __pcstackCOMMON
12CA  303A     MOVLW 0x3A
12CB  0271     SUBWF c, W
12CC  1803     BTFSC STATUS, 0x0
12CD  2AD4     GOTO 0x2D4
12CE  3030     MOVLW 0x30
12CF  0271     SUBWF c, W
12D0  1C03     BTFSS STATUS, 0x0
12D1  2AD4     GOTO 0x2D4
12D2  01F0     CLRF __pcstackCOMMON
12D3  0AF0     INCF __pcstackCOMMON, F
12D4  0C70     RRF __pcstackCOMMON, W
15:            }
12D5  0008     RETURN
16:            
17:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/fttol.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(__uint24 *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
000F  0843     MOVF f1, W
0010  00C7     MOVWF 0x47
0011  0844     MOVF 0x44, W
0012  00C8     MOVWF prec
0013  0845     MOVF 0x45, W
0014  00C9     MOVWF f1
0015  1003     BCF STATUS, 0x0
0016  0D48     RLF prec, W
0017  0D49     RLF f1, W
0018  00CA     MOVWF 0x4A
0019  084A     MOVF 0x4A, W
001A  00D0     MOVWF exp1
001B  0850     MOVF exp1, W
001C  1D03     BTFSS STATUS, 0x2
001D  2827     GOTO 0x27
50:            		return 0;
001E  3000     MOVLW 0x0
001F  00C6     MOVWF 0x46
0020  3000     MOVLW 0x0
0021  00C5     MOVWF 0x45
0022  3000     MOVLW 0x0
0023  00C4     MOVWF 0x44
0024  3000     MOVLW 0x0
0025  00C3     MOVWF f1
0026  0008     RETURN
51:            	sign1 = f1_as_mant1 >> 23;
0027  0843     MOVF f1, W
0028  00C7     MOVWF 0x47
0029  0844     MOVF 0x44, W
002A  00C8     MOVWF prec
002B  0845     MOVF 0x45, W
002C  00C9     MOVWF f1
002D  3017     MOVLW 0x17
002E  36C9     LSRF f1, F
002F  0CC8     RRF prec, F
0030  0CC7     RRF 0x47, F
0031  0B89     DECFSZ WREG, F
0032  282E     GOTO 0x2E
0033  0847     MOVF 0x47, W
0034  00CA     MOVWF 0x4A
0035  084A     MOVF 0x4A, W
0036  00CB     MOVWF sign1
52:            	f1_as_mant1 |= 0x8000UL;
0037  17C4     BSF 0x44, 0x7
53:            	f1_as_mant1 &= 0xFFFFUL;
0038  30FF     MOVLW 0xFF
0039  05C3     ANDWF f1, F
003A  30FF     MOVLW 0xFF
003B  05C4     ANDWF 0x44, F
003C  3000     MOVLW 0x0
003D  05C5     ANDWF 0x45, F
54:            	lval = f1_as_mant1;
003E  0843     MOVF f1, W
003F  00CC     MOVWF lval
0040  0844     MOVF 0x44, W
0041  00CD     MOVWF 0x4D
0042  0845     MOVF 0x45, W
0043  00CE     MOVWF 0x4E
0044  01CF     CLRF 0x4F
55:            	exp1 -= 127+15;
0045  308E     MOVLW 0x8E
0046  02D0     SUBWF exp1, F
56:            	if((signed char)exp1 < 0) {
0047  1FD0     BTFSS exp1, 0x7
0048  285C     GOTO 0x5C
57:            		if((signed char)exp1 < -15)
0049  0850     MOVF exp1, W
004A  3A80     XORLW 0x80
004B  3E8F     ADDLW 0x8F
004C  1C03     BTFSS STATUS, 0x0
004D  281E     GOTO 0x1E
58:            			return 0;
59:            		do
60:            			lval >>= 1;
004E  3001     MOVLW 0x1
004F  36CF     LSRF 0x4F, F
0050  0CCE     RRF 0x4E, F
0051  0CCD     RRF 0x4D, F
0052  0CCC     RRF lval, F
0053  0B89     DECFSZ WREG, F
0054  284F     GOTO 0x4F
61:            		while(++exp1 != 0);
0055  3001     MOVLW 0x1
0056  00C7     MOVWF 0x47
0057  0847     MOVF 0x47, W
0058  07D0     ADDWF exp1, F
0059  1903     BTFSC STATUS, 0x2
005A  286D     GOTO 0x6D
005B  284E     GOTO 0x4E
62:            	} else {
63:            		if(exp1 >= 24)
005C  3018     MOVLW 0x18
005D  0250     SUBWF exp1, W
005E  1803     BTFSC STATUS, 0x0
005F  281E     GOTO 0x1E
64:            			return 0;
65:            		while(exp1 != 0) {
006C  2860     GOTO 0x60
66:            			lval <<= 1;
0063  3001     MOVLW 0x1
0064  35CC     LSLF lval, F
0065  0DCD     RLF 0x4D, F
0066  0DCE     RLF 0x4E, F
0067  0DCF     RLF 0x4F, F
0068  0B89     DECFSZ WREG, F
0069  2864     GOTO 0x64
67:            			exp1--;
006A  3001     MOVLW 0x1
006B  02D0     SUBWF exp1, F
68:            		}
0060  0850     MOVF exp1, W
0061  1903     BTFSC STATUS, 0x2
0062  286D     GOTO 0x6D
69:            	}
70:            	if(sign1)
006D  084B     MOVF sign1, W
006E  1903     BTFSC STATUS, 0x2
006F  287B     GOTO 0x7B
71:            		lval = -lval;
0070  09CC     COMF lval, F
0071  09CD     COMF 0x4D, F
0072  09CE     COMF 0x4E, F
0073  09CF     COMF 0x4F, F
0074  0ACC     INCF lval, F
0075  1903     BTFSC STATUS, 0x2
0076  0ACD     INCF 0x4D, F
0077  1903     BTFSC STATUS, 0x2
0078  0ACE     INCF 0x4E, F
0079  1903     BTFSC STATUS, 0x2
007A  0ACF     INCF 0x4F, F
72:            	return lval;
007B  084F     MOVF 0x4F, W
007C  00C6     MOVWF 0x46
007D  084E     MOVF 0x4E, W
007E  00C5     MOVWF 0x45
007F  084D     MOVF 0x4D, W
0080  00C4     MOVWF 0x44
0081  084C     MOVF lval, W
0082  00C3     MOVWF f1
73:            }
0083  0008     RETURN
74:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/ftsub.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(__uint24 *)&f1)
11:            #define	f2_as_mant2	(*(__uint24 *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            #ifdef __PICC__
17:            __ftsub(float f2, float f1)
18:            #else
19:            __ftsub(float f1, float f2)
20:            #endif
21:            {
22:            	if (f2 != 0) {
131F  0858     MOVF 0x58, W
1320  0457     IORWF 0x57, W
1321  0456     IORWF f2, W
1322  1903     BTFSC STATUS, 0x2
1323  2B26     GOTO 0x326
23:            		f2_as_mant2 ^= 0x800000;
1324  3080     MOVLW 0x80
1325  06D8     XORWF 0x58, F
24:            	}
25:            	return __ftadd(f1, f2);
1326  0859     MOVF f1, W
1327  00C9     MOVWF f1
1328  085A     MOVF i, W
1329  00CA     MOVWF 0x4A
132A  085B     MOVF times, W
132B  00CB     MOVWF sign1
132C  0856     MOVF f2, W
132D  00CC     MOVWF lval
132E  0857     MOVF 0x57, W
132F  00CD     MOVWF 0x4D
1330  0858     MOVF 0x58, W
1331  00CE     MOVWF 0x4E
1332  3189     MOVLP 0x9
1333  211C     CALL 0x11C
1334  0849     MOVF f1, W
1335  00D6     MOVWF f2
1336  084A     MOVF 0x4A, W
1337  00D7     MOVWF 0x57
1338  084B     MOVF sign1, W
1339  00D8     MOVWF 0x58
26:            }
133A  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/ftneg.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	mant1	(*(__uint24 *)&f1)
11:            
12:            // Negate a float
13:            
14:            float
15:            __ftneg(float f1)
16:            {
17:            	if(f1 != 0)
12B7  0872     MOVF dividend, W
12B8  0471     IORWF c, W
12B9  0470     IORWF __pcstackCOMMON, W
12BA  1903     BTFSC STATUS, 0x2
12BB  0008     RETURN
18:            		mant1 ^= 0x800000UL;
12BC  3080     MOVLW 0x80
12BD  06F2     XORWF dividend, F
19:            	return f1;
20:            }
12BE  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/ftmul.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #ifdef _PIC18
9:             #define _Has_hardware_multiply 1
10:            #else
11:            #define _Has_hardware_multiply 0
12:            #endif
13:            
14:            #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
15:            #define _Has_large_call_stack 1
16:            #else
17:            #define _Has_large_call_stack 0
18:            #endif
19:            
20:            #include	"ftarith.h"
21:            
22:            #define	f1_as_plier	(*(__uint24 *)&f1)
23:            #define	f2_as_plicand	(*(__uint24 *)&f2)
24:            
25:            // floating addition
26:            #ifdef _OLDLIB
27:            #define	f3_as_product		(*(__uint24 *)&f3)
28:            float
29:            __ftmul(float f1, float f2)
30:            {
31:            	unsigned char	exp1, sign1, cntr;
32:            	float	f3;
33:            	
34:            	f3_as_product = 0;
35:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
36:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
37:            	if(cntr == 0 || exp1 == 0)
38:            		return f3;
39:            	exp1 += cntr-127-6;	// compute new exponent
40:            	cntr = 7;
41:            	do {
42:            		if(f1_as_plier & 1)
43:            			f3_as_product += f2_as_plicand;
44:            		f1_as_plier >>= 1;
45:            		f2_as_plicand <<= 1;
46:            	} while(--cntr != 0);
47:            	cntr = 9;
48:            	do {
49:            		if(f1_as_plier & 1)
50:            			f3_as_product += f2_as_plicand;
51:            		f1_as_plier >>= 1;
52:            		f3_as_product >>= 1;
53:            	} while(--cntr != 0);
54:            	__ftpack(&f3_as_product, exp1);
55:            	if(sign1)
56:            		f3_as_product |= 0x800000;
57:            	return f3;
58:            }
59:            #else
60:            #define	exp2	sign
61:            float
62:            __ftmul(float f1, float f2)
63:            {
64:            	unsigned char	exp, sign, cntr;
65:            	__uint24	f3_as_product;
66:            
67:            	if((exp = f1_as_plier >> 15) == 0)
1765  0828     MOVF f1, W
1766  00AE     MOVWF cntr
1767  0829     MOVF counter, W
1768  00AF     MOVWF f3
1769  082A     MOVF exp, W
176A  00B0     MOVWF 0x30
176B  1003     BCF STATUS, 0x0
176C  0D2F     RLF f3, W
176D  0D30     RLF 0x30, W
176E  00B1     MOVWF 0x31
176F  0831     MOVF 0x31, W
1770  00B2     MOVWF exp
1771  0832     MOVF exp, W
1772  1D03     BTFSS STATUS, 0x2
1773  2F7B     GOTO 0x77B
68:            		return 0.0;
1774  3000     MOVLW 0x0
1775  00A8     MOVWF f1
1776  3000     MOVLW 0x0
1777  00A9     MOVWF counter
1778  3000     MOVLW 0x0
1779  00AA     MOVWF exp
177A  0008     RETURN
69:            	if((exp2 = f2_as_plicand >> 15) == 0)
177B  082B     MOVF f2, W
177C  00AE     MOVWF cntr
177D  082C     MOVF 0x2C, W
177E  00AF     MOVWF f3
177F  082D     MOVF 0x2D, W
1780  00B0     MOVWF 0x30
1781  1003     BCF STATUS, 0x0
1782  0D2F     RLF f3, W
1783  0D30     RLF 0x30, W
1784  00B1     MOVWF 0x31
1785  0831     MOVF 0x31, W
1786  00B7     MOVWF sign
1787  0837     MOVF sign, W
1788  1D03     BTFSS STATUS, 0x2
1789  2F91     GOTO 0x791
70:            		return 0.0;
178A  3000     MOVLW 0x0
178B  00A8     MOVWF f1
178C  3000     MOVLW 0x0
178D  00A9     MOVWF counter
178E  3000     MOVLW 0x0
178F  00AA     MOVWF exp
1790  0008     RETURN
71:            	exp += exp2-127-6;	// compute new exponent
1791  0837     MOVF sign, W
1792  3E7B     ADDLW 0x7B
1793  00AE     MOVWF cntr
1794  082E     MOVF cntr, W
1795  07B2     ADDWF exp, F
72:            	sign = f1_as_plier >> 16;
1796  082A     MOVF exp, W
1797  00AE     MOVWF cntr
1798  082E     MOVF cntr, W
1799  00B7     MOVWF sign
73:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
179A  082D     MOVF 0x2D, W
179B  00AE     MOVWF cntr
179C  082E     MOVF cntr, W
179D  06B7     XORWF sign, F
74:            	sign &= 0x80;
179E  3080     MOVLW 0x80
179F  00AE     MOVWF cntr
17A0  082E     MOVF cntr, W
17A1  05B7     ANDWF sign, F
75:            	f1_as_plier |= 0x8000UL;
17A2  17A9     BSF counter, 0x7
76:            	//f1_as_plier &= 0xFFFFUL;		// not required
77:            	f2_as_plicand |= 0x8000UL;
17A3  17AC     BSF 0x2C, 0x7
78:            	f2_as_plicand &= 0xFFFFUL;
17A4  30FF     MOVLW 0xFF
17A5  05AB     ANDWF f2, F
17A6  30FF     MOVLW 0xFF
17A7  05AC     ANDWF 0x2C, F
17A8  3000     MOVLW 0x0
17A9  05AD     ANDWF 0x2D, F
79:            	f3_as_product = 0;
17AA  3000     MOVLW 0x0
17AB  00B3     MOVWF f3_as_product
17AC  3000     MOVLW 0x0
17AD  00B4     MOVWF 0x34
17AE  3000     MOVLW 0x0
17AF  00B5     MOVWF 0x35
80:            
81:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
82:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
83:            
84:            #define USE_SHRINK /* makes my test program smallest */
85:            
86:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
87:            /*
88:                     
89:            |seeeeeee|emmmmmmm|mmmmmmmm|
90:                     1.mmmmmmm mmmmmmmm
91:            
92:            a 16-bit multiply can be decomposed into the sum of four 8-bit multiplies
93:                   a  b
94:            *      c  d
95:            -----------
96:               ac| 0  0
97:                 |bc  0
98:                 |ad  0
99:            +    |   bd (we must not ignore this intermediate product
100:                        because it /can/ affect the high 16 bits of the result)
101:           ===========
102:            */
103:           	f1_as_plier &= 0xFFFFUL; /* required (see comment above) for this method */
104:           
105:                   f3_as_product  = ((unsigned int)LOWBYTE(f1_as_plier) * LOWBYTE(f2_as_plicand)) >> 8;
106:                   f3_as_product += (unsigned int)LOWBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand);
107:                   f3_as_product += (unsigned int)HIGHBYTE(f1_as_plier) * LOWBYTE(f2_as_plicand);
108:           #if defined(USE_MASKS)
109:                   f3_as_product += ((__uint24)
110:           			  ((unsigned int)HIGHBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand)))
111:           		<< 8;
112:           #elif defined(USE_SHRINK)
113:           	*((unsigned int*)(((unsigned char*)&f3_as_product)+1)) +=
114:           		(unsigned int)HIGHBYTE(f1_as_plier) * HIGHBYTE(f2_as_plicand);
115:           #else
116:           #error No method chosen
117:           #endif
118:           
119:           /*
120:           assuming normalized mantissa:
121:           smallest ac: 0x80 x 0x80 == 0x4000 .. shift down 7 bits
122:           largest ac:  0xff x 0xff == 0xfe01 .. shift down 8
123:            */
124:           	/* ensure result is normalized as expected by pack() */
125:           	if (f3_as_product & 0x800000u) {
126:           		f3_as_product >>= 1;
127:           		exp++;
128:           	}
129:           	f3_as_product >>= 1;
130:           
131:           #else
132:           	/* f1 & 0x8000 == 0x8000 */
133:           	/* f2 & 0x8000 == 0x8000 */
134:           	cntr = 7;
17B0  3007     MOVLW 0x7
17B1  00AE     MOVWF cntr
17B2  082E     MOVF cntr, W
17B3  00B6     MOVWF cntr
135:           	do {
136:           		if(f1_as_plier & 1)
17B4  1C28     BTFSS f1, 0x0
17B5  2FBC     GOTO 0x7BC
137:           			f3_as_product += f2_as_plicand;
17B6  082B     MOVF f2, W
17B7  07B3     ADDWF f3_as_product, F
17B8  082C     MOVF 0x2C, W
17B9  3DB4     ADDWFC 0x34, F
17BA  082D     MOVF 0x2D, W
17BB  3DB5     ADDWFC 0x35, F
138:           		f1_as_plier >>= 1;
17BC  3001     MOVLW 0x1
17BD  36AA     LSRF exp, F
17BE  0CA9     RRF counter, F
17BF  0CA8     RRF f1, F
17C0  0B89     DECFSZ WREG, F
17C1  2FBD     GOTO 0x7BD
139:           		f2_as_plicand <<= 1;
17C2  3001     MOVLW 0x1
17C3  35AB     LSLF f2, F
17C4  0DAC     RLF 0x2C, F
17C5  0DAD     RLF 0x2D, F
17C6  0B89     DECFSZ WREG, F
17C7  2FC3     GOTO 0x7C3
140:           	} while(--cntr != 0);
17C8  3001     MOVLW 0x1
17C9  02B6     SUBWF cntr, F
17CA  1D03     BTFSS STATUS, 0x2
17CB  2FB4     GOTO 0x7B4
141:           	/* f1 & 0x100 == 0x100 */
142:           	/* f2 & 0x400000 == 0x400000 */
143:           	cntr = 9;
17CC  3009     MOVLW 0x9
17CD  00AE     MOVWF cntr
17CE  082E     MOVF cntr, W
17CF  00B6     MOVWF cntr
144:           	do {
145:           		if(f1_as_plier & 1)
17D0  1C28     BTFSS f1, 0x0
17D1  2FD8     GOTO 0x7D8
146:           			f3_as_product += f2_as_plicand;
17D2  082B     MOVF f2, W
17D3  07B3     ADDWF f3_as_product, F
17D4  082C     MOVF 0x2C, W
17D5  3DB4     ADDWFC 0x34, F
17D6  082D     MOVF 0x2D, W
17D7  3DB5     ADDWFC 0x35, F
147:           		f1_as_plier >>= 1;
17D8  3001     MOVLW 0x1
17D9  36AA     LSRF exp, F
17DA  0CA9     RRF counter, F
17DB  0CA8     RRF f1, F
17DC  0B89     DECFSZ WREG, F
17DD  2FD9     GOTO 0x7D9
148:           		f3_as_product >>= 1;
17DE  3001     MOVLW 0x1
17DF  36B5     LSRF 0x35, F
17E0  0CB4     RRF 0x34, F
17E1  0CB3     RRF f3_as_product, F
17E2  0B89     DECFSZ WREG, F
17E3  2FDF     GOTO 0x7DF
149:           	} while(--cntr != 0);
17E4  3001     MOVLW 0x1
17E5  02B6     SUBWF cntr, F
17E6  1D03     BTFSS STATUS, 0x2
17E7  2FD0     GOTO 0x7D0
150:           	/* f1 == 0 */
151:           	/* f2 & 0x400000 == 0x400000 */
152:           	/* because the last bit of f1 _was_ set,
153:           	   f3 & 0x200000 == 0x200000 and
154:           	   f3 & 0xc00000 == 0 */
155:           #endif
156:           	return __ftpack(f3_as_product, exp, sign);
17E8  0833     MOVF f3_as_product, W
17E9  00F0     MOVWF __pcstackCOMMON
17EA  0834     MOVF 0x34, W
17EB  00F1     MOVWF c
17EC  0835     MOVF 0x35, W
17ED  00F2     MOVWF dividend
17EE  0832     MOVF exp, W
17EF  00AE     MOVWF cntr
17F0  082E     MOVF cntr, W
17F1  00F3     MOVWF exp
17F2  0837     MOVF sign, W
17F3  00AF     MOVWF f3
17F4  082F     MOVF f3, W
17F5  00F4     MOVWF sign
17F6  3188     MOVLP 0x8
17F7  201C     CALL 0x1C
17F8  0870     MOVF __pcstackCOMMON, W
17F9  0020     MOVLB 0x0
17FA  00A8     MOVWF f1
17FB  0871     MOVF c, W
17FC  00A9     MOVWF counter
17FD  0872     MOVF dividend, W
17FE  00AA     MOVWF exp
157:           }
17FF  0008     RETURN
158:           #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/ftge.c  --------------------------
1:             #define	f1	(*(__uint24 *)&ff1)
2:             #define	f2	(*(__uint24 *)&ff2)
3:             __bit
4:             __ftge(float ff1, float ff2)
5:             {
6:             	if(f1 &  0x800000UL)
13C3  1FF2     BTFSS dividend, 0x7
13C4  2BD2     GOTO 0x3D2
7:             		f1 = 0x800000UL - f1;
13C5  0870     MOVF __pcstackCOMMON, W
13C6  3C00     SUBLW 0x0
13C7  00F0     MOVWF __pcstackCOMMON
13C8  0871     MOVF c, W
13C9  1C03     BTFSS STATUS, 0x0
13CA  0F71     INCFSZ c, W
13CB  3C00     SUBLW 0x0
13CC  00F1     MOVWF c
13CD  0872     MOVF dividend, W
13CE  1C03     BTFSS STATUS, 0x0
13CF  0F72     INCFSZ dividend, W
13D0  3C80     SUBLW 0x80
13D1  00F2     MOVWF dividend
8:             	if(f2 &  0x800000UL)
13D2  1FF5     BTFSS rem, 0x7
13D3  2BE1     GOTO 0x3E1
9:             		f2 = 0x800000UL - f2;
13D4  0873     MOVF exp, W
13D5  3C00     SUBLW 0x0
13D6  00F3     MOVWF exp
13D7  0874     MOVF sign, W
13D8  1C03     BTFSS STATUS, 0x0
13D9  0F74     INCFSZ sign, W
13DA  3C00     SUBLW 0x0
13DB  00F4     MOVWF sign
13DC  0875     MOVF rem, W
13DD  1C03     BTFSS STATUS, 0x0
13DE  0F75     INCFSZ rem, W
13DF  3C80     SUBLW 0x80
13E0  00F5     MOVWF rem
10:            	f1 ^= 0x800000UL;
13E1  3080     MOVLW 0x80
13E2  06F2     XORWF dividend, F
11:            	f2 ^= 0x800000UL;
13E3  3080     MOVLW 0x80
13E4  06F5     XORWF rem, F
12:            	return f1 >= f2;
13E5  0875     MOVF rem, W
13E6  0272     SUBWF dividend, W
13E7  1D03     BTFSS STATUS, 0x2
13E8  0008     RETURN
13E9  0874     MOVF sign, W
13EA  0271     SUBWF c, W
13EB  1D03     BTFSS STATUS, 0x2
13EC  0008     RETURN
13ED  0873     MOVF exp, W
13EE  0270     SUBWF __pcstackCOMMON, W
13EF  0008     RETURN
13:            }
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/ftdivl.c  ------------------------
1:             
2:             
3:             /*	Floating point routines.
4:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
5:             
6:             	divide two floats, convert the result directly to an unsigned long
7:             
8:             */
9:             
10:            // this is bigendian code right now. Need to parameterise it.
11:            
12:            #include	"ftarith.h"
13:            
14:            #define	f1_as_dividend	(*(__uint24 *)&f1)
15:            #define	f2_as_divisor	(*(__uint24 *)&f2)
16:            #ifdef _OLDLIB
17:            unsigned long int
18:            _tdiv_to_l_(float f1, float f2)
19:            {
20:            	unsigned char	cntr, exp1;
21:            	unsigned long	quot;
22:            	
23:            	quot = 0;
24:            	__ftunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return quot;
27:            	__ftunpack(&f2_as_divisor, &cntr);
28:            	if(cntr == 0)
29:            		return quot;
30:            	exp1 -= 127;
31:            	exp1 -= cntr-127+23;	// compute new exponent
32:            	cntr = 32;
33:            	do {
34:            		quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	if((signed char)exp1 < 0) {
42:            		if((signed char)exp1 < -31)
43:            			return 0;
44:            		do
45:            			quot >>= 1;
46:            		while(++exp1 != 0);
47:            	} else {
48:            		if(exp1 >= 32)
49:            			return 0;
50:            		while(exp1 != 0) {
51:            			quot <<= 1;
52:            			exp1--;
53:            		}
54:            	}
55:            	return quot;
56:            }
57:            #else
58:            #define	exp2			cntr
59:            unsigned long int
60:            _tdiv_to_l_(float f1, float f2)
61:            {
62:            	unsigned char	cntr, exp1;
63:            	unsigned long	quot;
64:            	
65:            	// unpack the operands
66:            	if((exp1 = f1_as_dividend >> 15) == 0)
0880  0870     MOVF __pcstackCOMMON, W
0881  00F6     MOVWF divisor
0882  0871     MOVF c, W
0883  00F7     MOVWF divisor
0884  0872     MOVF dividend, W
0885  00F8     MOVWF c
0886  1003     BCF STATUS, 0x0
0887  0D77     RLF divisor, W
0888  0D78     RLF c, W
0889  00F9     MOVWF counter
088A  0879     MOVF counter, W
088B  0020     MOVLB 0x0
088C  00A5     MOVWF exp1
088D  0825     MOVF exp1, W
088E  1D03     BTFSS STATUS, 0x2
088F  2899     GOTO 0x99
67:            		return 0;
0890  3000     MOVLW 0x0
0891  00F3     MOVWF exp
0892  3000     MOVLW 0x0
0893  00F2     MOVWF dividend
0894  3000     MOVLW 0x0
0895  00F1     MOVWF c
0896  3000     MOVLW 0x0
0897  00F0     MOVWF __pcstackCOMMON
0898  0008     RETURN
68:            	if((exp2 = f2_as_divisor >> 15) == 0)
0899  0873     MOVF exp, W
089A  00F6     MOVWF divisor
089B  0874     MOVF sign, W
089C  00F7     MOVWF divisor
089D  0875     MOVF rem, W
089E  00F8     MOVWF c
089F  1003     BCF STATUS, 0x0
08A0  0D77     RLF divisor, W
08A1  0D78     RLF c, W
08A2  00F9     MOVWF counter
08A3  0879     MOVF counter, W
08A4  00A4     MOVWF multiplier
08A5  0824     MOVF multiplier, W
08A6  1903     BTFSC STATUS, 0x2
08A7  2890     GOTO 0x90
69:            		return 0;
70:            	f1_as_dividend |= 0x8000UL;
08A8  17F1     BSF c, 0x7
71:            	f1_as_dividend &= 0xFFFFUL;
08A9  30FF     MOVLW 0xFF
08AA  05F0     ANDWF __pcstackCOMMON, F
08AB  30FF     MOVLW 0xFF
08AC  05F1     ANDWF c, F
08AD  3000     MOVLW 0x0
08AE  05F2     ANDWF dividend, F
72:            	f2_as_divisor |= 0x8000UL;
08AF  17F4     BSF sign, 0x7
73:            	f2_as_divisor &= 0xFFFFUL;
08B0  30FF     MOVLW 0xFF
08B1  05F3     ANDWF exp, F
08B2  30FF     MOVLW 0xFF
08B3  05F4     ANDWF sign, F
08B4  3000     MOVLW 0x0
08B5  05F5     ANDWF rem, F
74:            	quot = 0;
08B6  3000     MOVLW 0x0
08B7  00A3     MOVWF 0x23
08B8  3000     MOVLW 0x0
08B9  00A2     MOVWF quotient
08BA  3000     MOVLW 0x0
08BB  00A1     MOVWF sign
08BC  3000     MOVLW 0x0
08BD  00A0     MOVWF __pcstackBANK0
75:            	exp1 -= 127;
08BE  307F     MOVLW 0x7F
08BF  02A5     SUBWF exp1, F
76:            	exp1 -= cntr-127+23;	// compute new exponent
08C0  3098     MOVLW 0x98
08C1  0724     ADDWF multiplier, W
08C2  00F6     MOVWF divisor
08C3  0876     MOVF divisor, W
08C4  02A5     SUBWF exp1, F
77:            	cntr = 24;
08C5  3018     MOVLW 0x18
08C6  00F6     MOVWF divisor
08C7  0876     MOVF divisor, W
08C8  00A4     MOVWF multiplier
78:            	do {
79:            		quot <<= 1;
08C9  3001     MOVLW 0x1
08CA  35A0     LSLF __pcstackBANK0, F
08CB  0DA1     RLF sign, F
08CC  0DA2     RLF quotient, F
08CD  0DA3     RLF 0x23, F
08CE  0B89     DECFSZ WREG, F
08CF  28CA     GOTO 0xCA
80:            		if(f1_as_dividend >= f2_as_divisor) {
08D0  0875     MOVF rem, W
08D1  0272     SUBWF dividend, W
08D2  1D03     BTFSS STATUS, 0x2
08D3  28DA     GOTO 0xDA
08D4  0874     MOVF sign, W
08D5  0271     SUBWF c, W
08D6  1D03     BTFSS STATUS, 0x2
08D7  28DA     GOTO 0xDA
08D8  0873     MOVF exp, W
08D9  0270     SUBWF __pcstackCOMMON, W
08DA  1C03     BTFSS STATUS, 0x0
08DB  28E3     GOTO 0xE3
81:            			f1_as_dividend -= f2_as_divisor;
08DC  0873     MOVF exp, W
08DD  02F0     SUBWF __pcstackCOMMON, F
08DE  0874     MOVF sign, W
08DF  3BF1     SUBWFB c, F
08E0  0875     MOVF rem, W
08E1  3BF2     SUBWFB dividend, F
82:            			quot |= 1;
08E2  1420     BSF __pcstackBANK0, 0x0
83:            		}
84:            		f1_as_dividend <<= 1;
08E3  3001     MOVLW 0x1
08E4  35F0     LSLF __pcstackCOMMON, F
08E5  0DF1     RLF c, F
08E6  0DF2     RLF dividend, F
08E7  0B89     DECFSZ WREG, F
08E8  28E4     GOTO 0xE4
85:            	} while(--cntr != 0);
08E9  3001     MOVLW 0x1
08EA  02A4     SUBWF multiplier, F
08EB  1D03     BTFSS STATUS, 0x2
08EC  28C9     GOTO 0xC9
86:            	if((signed char)exp1 < 0) {
08ED  1FA5     BTFSS exp1, 0x7
08EE  2902     GOTO 0x102
87:            		if((signed char)exp1 < -23)
08EF  0825     MOVF exp1, W
08F0  3A80     XORLW 0x80
08F1  3E97     ADDLW 0x97
08F2  1C03     BTFSS STATUS, 0x0
08F3  2890     GOTO 0x90
88:            			return 0;
89:            		do
90:            			quot >>= 1;
08F4  3001     MOVLW 0x1
08F5  36A3     LSRF 0x23, F
08F6  0CA2     RRF quotient, F
08F7  0CA1     RRF sign, F
08F8  0CA0     RRF __pcstackBANK0, F
08F9  0B89     DECFSZ WREG, F
08FA  28F5     GOTO 0xF5
91:            		while(++exp1 != 0);
08FB  3001     MOVLW 0x1
08FC  00F6     MOVWF divisor
08FD  0876     MOVF divisor, W
08FE  07A5     ADDWF exp1, F
08FF  1903     BTFSC STATUS, 0x2
0900  2913     GOTO 0x113
0901  28F4     GOTO 0xF4
92:            	} else {
93:            		if(exp1 >= 24)
0902  3018     MOVLW 0x18
0903  0225     SUBWF exp1, W
0904  1803     BTFSC STATUS, 0x0
0905  2890     GOTO 0x90
94:            			return 0;
95:            		while(exp1 != 0) {
0912  2906     GOTO 0x106
96:            			quot <<= 1;
0909  3001     MOVLW 0x1
090A  35A0     LSLF __pcstackBANK0, F
090B  0DA1     RLF sign, F
090C  0DA2     RLF quotient, F
090D  0DA3     RLF 0x23, F
090E  0B89     DECFSZ WREG, F
090F  290A     GOTO 0x10A
97:            			exp1--;
0910  3001     MOVLW 0x1
0911  02A5     SUBWF exp1, F
98:            		}
0906  0825     MOVF exp1, W
0907  1903     BTFSC STATUS, 0x2
0908  2913     GOTO 0x113
99:            	}
100:           	return quot;
0913  0823     MOVF 0x23, W
0914  00F3     MOVWF exp
0915  0822     MOVF quotient, W
0916  00F2     MOVWF dividend
0917  0821     MOVF sign, W
0918  00F1     MOVWF c
0919  0820     MOVF __pcstackBANK0, W
091A  00F0     MOVWF __pcstackCOMMON
101:           }	
091B  0008     RETURN
102:           #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/ftdiv.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_dividend	(*(__uint24 *)&f1)
11:            #define	f2_as_divisor	(*(__uint24 *)&f2)
12:            #define	f3_as_quot	(*(__uint24 *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            float
18:            #ifdef _PIC18
19:            __ftdiv(float f1, float f2)
20:            #else
21:            __ftdiv(float f2, float f1)
22:            #endif
23:            {
24:            	unsigned char	exp1, exp2, sign1, sign2;
25:            	float	f3;
26:            	
27:            	f3_as_quot = 0;
28:            	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:            	if(exp1 == 0)
30:            		return f3;
31:            	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:            	if(exp2 == 0)
33:            		return f3;
34:            	exp1 -= exp2-127+8;	// compute new exponent
35:            	sign1 ^= sign2;
36:            	cntr = 16+8;
37:            	do {
38:            		f3_as_quot <<= 1;
39:            		if(f1_as_dividend >= f2_as_divisor) {
40:            			f1_as_dividend -= f2_as_divisor;
41:            			f3_as_quot |= 1;
42:            		}
43:            		f1_as_dividend <<= 1;
44:            	} while(--cntr != 0);
45:            	__ftpack(&f3_as_quot, exp1);
46:            	if(sign1)
47:            		f3_as_quot |= 0x800000;
48:            	return f3;
49:            }
50:            #else
51:            #define	exp2	sign
52:            float
53:            #ifdef _PIC18
54:            __ftdiv(float f1, float f2)
55:            #else
56:            __ftdiv(float f2, float f1)
57:            #endif
58:            {
59:            	unsigned char	exp, sign, cntr;
60:            	float	f3;
61:            	
62:            	// unpack the operands
63:            	if((exp = f1_as_dividend >> 15) == 0)
16D5  0827     MOVF f1, W
16D6  00AA     MOVWF exp
16D7  0828     MOVF f1, W
16D8  00AB     MOVWF f2
16D9  0829     MOVF counter, W
16DA  00AC     MOVWF 0x2C
16DB  1003     BCF STATUS, 0x0
16DC  0D2B     RLF f2, W
16DD  0D2C     RLF 0x2C, W
16DE  00AD     MOVWF 0x2D
16DF  082D     MOVF 0x2D, W
16E0  00B2     MOVWF exp
16E1  0832     MOVF exp, W
16E2  1D03     BTFSS STATUS, 0x2
16E3  2EEB     GOTO 0x6EB
64:            		return 0.0;
16E4  3000     MOVLW 0x0
16E5  00A4     MOVWF multiplier
16E6  3000     MOVLW 0x0
16E7  00A5     MOVWF exp1
16E8  3000     MOVLW 0x0
16E9  00A6     MOVWF multiplicand
16EA  0008     RETURN
65:            	if((exp2 = f2_as_divisor >> 15) == 0)
16EB  0824     MOVF multiplier, W
16EC  00AA     MOVWF exp
16ED  0825     MOVF exp1, W
16EE  00AB     MOVWF f2
16EF  0826     MOVF multiplicand, W
16F0  00AC     MOVWF 0x2C
16F1  1003     BCF STATUS, 0x0
16F2  0D2B     RLF f2, W
16F3  0D2C     RLF 0x2C, W
16F4  00AD     MOVWF 0x2D
16F5  082D     MOVF 0x2D, W
16F6  00B3     MOVWF f3_as_product
16F7  0833     MOVF f3_as_product, W
16F8  1D03     BTFSS STATUS, 0x2
16F9  2F01     GOTO 0x701
66:            		return 0.0;
16FA  3000     MOVLW 0x0
16FB  00A4     MOVWF multiplier
16FC  3000     MOVLW 0x0
16FD  00A5     MOVWF exp1
16FE  3000     MOVLW 0x0
16FF  00A6     MOVWF multiplicand
1700  0008     RETURN
67:            	f3_as_quot = 0;
1701  3000     MOVLW 0x0
1702  00AF     MOVWF f3
1703  3000     MOVLW 0x0
1704  00B0     MOVWF 0x30
1705  3000     MOVLW 0x0
1706  00B1     MOVWF 0x31
68:            	exp -= exp2-127+8;	// compute new exponent
1707  3089     MOVLW 0x89
1708  0733     ADDWF f3_as_product, W
1709  00AA     MOVWF exp
170A  082A     MOVF exp, W
170B  02B2     SUBWF exp, F
69:            	sign = f1_as_dividend >> 16;
170C  0829     MOVF counter, W
170D  00AA     MOVWF exp
170E  082A     MOVF exp, W
170F  00B3     MOVWF f3_as_product
70:            	sign ^= (unsigned char)(f2_as_divisor >> 16);
1710  0826     MOVF multiplicand, W
1711  00AA     MOVWF exp
1712  082A     MOVF exp, W
1713  06B3     XORWF f3_as_product, F
71:            	sign &= 0x80;
1714  3080     MOVLW 0x80
1715  00AA     MOVWF exp
1716  082A     MOVF exp, W
1717  05B3     ANDWF f3_as_product, F
72:            	f1_as_dividend |= 0x8000UL;
1718  17A8     BSF f1, 0x7
73:            	f1_as_dividend &= 0xFFFFUL;
1719  30FF     MOVLW 0xFF
171A  05A7     ANDWF f1, F
171B  30FF     MOVLW 0xFF
171C  05A8     ANDWF f1, F
171D  3000     MOVLW 0x0
171E  05A9     ANDWF counter, F
74:            	f2_as_divisor |= 0x8000UL;
171F  17A5     BSF exp1, 0x7
75:            	f2_as_divisor &= 0xFFFFUL;
1720  30FF     MOVLW 0xFF
1721  05A4     ANDWF multiplier, F
1722  30FF     MOVLW 0xFF
1723  05A5     ANDWF exp1, F
1724  3000     MOVLW 0x0
1725  05A6     ANDWF multiplicand, F
76:            	cntr = 16+8;
1726  3018     MOVLW 0x18
1727  00AA     MOVWF exp
1728  082A     MOVF exp, W
1729  00AE     MOVWF cntr
77:            	do {
78:            		f3_as_quot <<= 1;
172A  3001     MOVLW 0x1
172B  35AF     LSLF f3, F
172C  0DB0     RLF 0x30, F
172D  0DB1     RLF 0x31, F
172E  0B89     DECFSZ WREG, F
172F  2F2B     GOTO 0x72B
79:            		if(f1_as_dividend >= f2_as_divisor) {
1730  0826     MOVF multiplicand, W
1731  0229     SUBWF counter, W
1732  1D03     BTFSS STATUS, 0x2
1733  2F3A     GOTO 0x73A
1734  0825     MOVF exp1, W
1735  0228     SUBWF f1, W
1736  1D03     BTFSS STATUS, 0x2
1737  2F3A     GOTO 0x73A
1738  0824     MOVF multiplier, W
1739  0227     SUBWF f1, W
173A  1C03     BTFSS STATUS, 0x0
173B  2F43     GOTO 0x743
80:            			f1_as_dividend -= f2_as_divisor;
173C  0824     MOVF multiplier, W
173D  02A7     SUBWF f1, F
173E  0825     MOVF exp1, W
173F  3BA8     SUBWFB f1, F
1740  0826     MOVF multiplicand, W
1741  3BA9     SUBWFB counter, F
81:            			f3_as_quot |= 1;
1742  142F     BSF f3, 0x0
82:            		}
83:            		f1_as_dividend <<= 1;
1743  3001     MOVLW 0x1
1744  35A7     LSLF f1, F
1745  0DA8     RLF f1, F
1746  0DA9     RLF counter, F
1747  0B89     DECFSZ WREG, F
1748  2F44     GOTO 0x744
84:            	} while(--cntr != 0);
1749  3001     MOVLW 0x1
174A  02AE     SUBWF cntr, F
174B  1D03     BTFSS STATUS, 0x2
174C  2F2A     GOTO 0x72A
85:            	return __ftpack(f3_as_quot, exp, sign);
174D  082F     MOVF f3, W
174E  00F0     MOVWF __pcstackCOMMON
174F  0830     MOVF 0x30, W
1750  00F1     MOVWF c
1751  0831     MOVF 0x31, W
1752  00F2     MOVWF dividend
1753  0832     MOVF exp, W
1754  00AA     MOVWF exp
1755  082A     MOVF exp, W
1756  00F3     MOVWF exp
1757  0833     MOVF f3_as_product, W
1758  00AB     MOVWF f2
1759  082B     MOVF f2, W
175A  00F4     MOVWF sign
175B  3188     MOVLP 0x8
175C  201C     CALL 0x1C
175D  0870     MOVF __pcstackCOMMON, W
175E  0020     MOVLB 0x0
175F  00A4     MOVWF multiplier
1760  0871     MOVF c, W
1761  00A5     MOVWF exp1
1762  0872     MOVF dividend, W
1763  00A6     MOVWF multiplicand
86:            }
1764  0008     RETURN
87:            #endif	
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/ftadd.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(__uint24 *)&f1)
11:            #define	f2_as_mant2	(*(__uint24 *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
091C  0849     MOVF f1, W
091D  00CF     MOVWF 0x4F
091E  084A     MOVF 0x4A, W
091F  00D0     MOVWF exp1
0920  084B     MOVF sign1, W
0921  00D1     MOVWF 0x51
0922  1003     BCF STATUS, 0x0
0923  0D50     RLF exp1, W
0924  0D51     RLF 0x51, W
0925  00D2     MOVWF 0x52
0926  0852     MOVF 0x52, W
0927  00D5     MOVWF exp1
91:            	exp2 = f2_as_mant2 >> 15;
0928  084C     MOVF lval, W
0929  00CF     MOVWF 0x4F
092A  084D     MOVF 0x4D, W
092B  00D0     MOVWF exp1
092C  084E     MOVF 0x4E, W
092D  00D1     MOVWF 0x51
092E  1003     BCF STATUS, 0x0
092F  0D50     RLF exp1, W
0930  0D51     RLF 0x51, W
0931  00D2     MOVWF 0x52
0932  0852     MOVF 0x52, W
0933  00D4     MOVWF exp2
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
0934  0855     MOVF exp1, W
0935  1903     BTFSC STATUS, 0x2
0936  2943     GOTO 0x143
0937  0854     MOVF exp2, W
0938  0255     SUBWF exp1, W
0939  1803     BTFSC STATUS, 0x0
093A  294A     GOTO 0x14A
093B  0854     MOVF exp2, W
093C  00CF     MOVWF 0x4F
093D  0855     MOVF exp1, W
093E  02CF     SUBWF 0x4F, F
093F  3019     MOVLW 0x19
0940  024F     SUBWF 0x4F, W
0941  1C03     BTFSS STATUS, 0x0
0942  294A     GOTO 0x14A
93:            		return f2;
0943  084C     MOVF lval, W
0944  00C9     MOVWF f1
0945  084D     MOVF 0x4D, W
0946  00CA     MOVWF 0x4A
0947  084E     MOVF 0x4E, W
0948  00CB     MOVWF sign1
0949  0008     RETURN
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
094A  0854     MOVF exp2, W
094B  1903     BTFSC STATUS, 0x2
094C  0008     RETURN
094D  0855     MOVF exp1, W
094E  0254     SUBWF exp2, W
094F  1803     BTFSC STATUS, 0x0
0950  2959     GOTO 0x159
0951  0855     MOVF exp1, W
0952  00CF     MOVWF 0x4F
0953  0854     MOVF exp2, W
0954  02CF     SUBWF 0x4F, F
0955  3019     MOVLW 0x19
0956  024F     SUBWF 0x4F, W
0957  1803     BTFSC STATUS, 0x0
0958  0008     RETURN
95:            		return f1;
96:            	sign = 6;
0959  3006     MOVLW 0x6
095A  00CF     MOVWF 0x4F
095B  084F     MOVF 0x4F, W
095C  00D3     MOVWF sign
97:            	if(f1_as_mant1 & 0x800000L)
095D  1BCB     BTFSC sign1, 0x7
98:            		sign |= 0x80;
095E  17D3     BSF sign, 0x7
99:            	if(f2_as_mant2 & 0x800000L)
095F  1BCE     BTFSC 0x4E, 0x7
100:           		sign |= 0x40;
0960  1753     BSF sign, 0x6
101:           	f1_as_mant1 |= 0x8000UL;
0961  17CA     BSF 0x4A, 0x7
102:           	f1_as_mant1 &= 0xFFFFUL;
0962  30FF     MOVLW 0xFF
0963  05C9     ANDWF f1, F
0964  30FF     MOVLW 0xFF
0965  05CA     ANDWF 0x4A, F
0966  3000     MOVLW 0x0
0967  05CB     ANDWF sign1, F
103:           	f2_as_mant2 |= 0x8000UL;
0968  17CD     BSF 0x4D, 0x7
104:           	f2_as_mant2 &= 0xFFFFUL;
0969  30FF     MOVLW 0xFF
096A  05CC     ANDWF lval, F
096B  30FF     MOVLW 0xFF
096C  05CD     ANDWF 0x4D, F
096D  3000     MOVLW 0x0
096E  05CE     ANDWF 0x4E, F
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
096F  0854     MOVF exp2, W
0970  0255     SUBWF exp1, W
0971  1803     BTFSC STATUS, 0x0
0972  2995     GOTO 0x195
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
0973  3001     MOVLW 0x1
0974  35CC     LSLF lval, F
0975  0DCD     RLF 0x4D, F
0976  0DCE     RLF 0x4E, F
0977  0B89     DECFSZ WREG, F
0978  2974     GOTO 0x174
111:           			exp2--;
0979  3001     MOVLW 0x1
097A  02D4     SUBWF exp2, F
112:           		} while(exp2 != exp1 && --sign & 7);
097B  0854     MOVF exp2, W
097C  0655     XORWF exp1, W
097D  1903     BTFSC STATUS, 0x2
097E  2990     GOTO 0x190
097F  3001     MOVLW 0x1
0980  02D3     SUBWF sign, F
0981  0853     MOVF sign, W
0982  3907     ANDLW 0x7
0983  1903     BTFSC STATUS, 0x2
0984  2990     GOTO 0x190
0985  2973     GOTO 0x173
113:           		while(exp1 != exp2) {
0990  0855     MOVF exp1, W
0991  0654     XORWF exp2, W
0992  1903     BTFSC STATUS, 0x2
0993  29BA     GOTO 0x1BA
0994  2986     GOTO 0x186
114:           			f1_as_mant1 >>= 1;
0986  3001     MOVLW 0x1
0987  36CB     LSRF sign1, F
0988  0CCA     RRF 0x4A, F
0989  0CC9     RRF f1, F
098A  0B89     DECFSZ WREG, F
098B  2987     GOTO 0x187
115:           			exp1++;
098C  3001     MOVLW 0x1
098D  00CF     MOVWF 0x4F
098E  084F     MOVF 0x4F, W
098F  07D5     ADDWF exp1, F
116:           		}
117:           	} else if(exp1 > exp2) {
0995  0855     MOVF exp1, W
0996  0254     SUBWF exp2, W
0997  1803     BTFSC STATUS, 0x0
0998  29BA     GOTO 0x1BA
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
0999  3001     MOVLW 0x1
099A  35C9     LSLF f1, F
099B  0DCA     RLF 0x4A, F
099C  0DCB     RLF sign1, F
099D  0B89     DECFSZ WREG, F
099E  299A     GOTO 0x19A
122:           			exp1--;
099F  3001     MOVLW 0x1
09A0  02D5     SUBWF exp1, F
123:           		} while(exp2 != exp1 && --sign & 7);
09A1  0854     MOVF exp2, W
09A2  0655     XORWF exp1, W
09A3  1903     BTFSC STATUS, 0x2
09A4  29B6     GOTO 0x1B6
09A5  3001     MOVLW 0x1
09A6  02D3     SUBWF sign, F
09A7  0853     MOVF sign, W
09A8  3907     ANDLW 0x7
09A9  1903     BTFSC STATUS, 0x2
09AA  29B6     GOTO 0x1B6
09AB  2999     GOTO 0x199
124:           		while(exp1 != exp2) {
09B6  0855     MOVF exp1, W
09B7  0654     XORWF exp2, W
09B8  1D03     BTFSS STATUS, 0x2
09B9  29AC     GOTO 0x1AC
125:           			f2_as_mant2 >>= 1;
09AC  3001     MOVLW 0x1
09AD  36CE     LSRF 0x4E, F
09AE  0CCD     RRF 0x4D, F
09AF  0CCC     RRF lval, F
09B0  0B89     DECFSZ WREG, F
09B1  29AD     GOTO 0x1AD
126:           			exp2++;
09B2  3001     MOVLW 0x1
09B3  00CF     MOVWF 0x4F
09B4  084F     MOVF 0x4F, W
09B5  07D4     ADDWF exp2, F
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
09BA  1FD3     BTFSS sign, 0x7
09BB  29CC     GOTO 0x1CC
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
09BC  30FF     MOVLW 0xFF
09BD  06C9     XORWF f1, F
09BE  30FF     MOVLW 0xFF
09BF  06CA     XORWF 0x4A, F
09C0  30FF     MOVLW 0xFF
09C1  06CB     XORWF sign1, F
132:           		f1_as_mant1++;
09C2  3001     MOVLW 0x1
09C3  07C9     ADDWF f1, F
09C4  3000     MOVLW 0x0
09C5  1803     BTFSC STATUS, 0x0
09C6  3001     MOVLW 0x1
09C7  07CA     ADDWF 0x4A, F
09C8  3000     MOVLW 0x0
09C9  1803     BTFSC STATUS, 0x0
09CA  3001     MOVLW 0x1
09CB  07CB     ADDWF sign1, F
133:           	}
134:           	if(sign & 0x40) {
09CC  1F53     BTFSS sign, 0x6
09CD  29DE     GOTO 0x1DE
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
09CE  30FF     MOVLW 0xFF
09CF  06CC     XORWF lval, F
09D0  30FF     MOVLW 0xFF
09D1  06CD     XORWF 0x4D, F
09D2  30FF     MOVLW 0xFF
09D3  06CE     XORWF 0x4E, F
137:           		f2_as_mant2++;
09D4  3001     MOVLW 0x1
09D5  07CC     ADDWF lval, F
09D6  3000     MOVLW 0x0
09D7  1803     BTFSC STATUS, 0x0
09D8  3001     MOVLW 0x1
09D9  07CD     ADDWF 0x4D, F
09DA  3000     MOVLW 0x0
09DB  1803     BTFSC STATUS, 0x0
09DC  3001     MOVLW 0x1
09DD  07CE     ADDWF 0x4E, F
138:           	}
139:           	sign = 0;
09DE  01D3     CLRF sign
140:           	f2_as_mant2 += f1_as_mant1;
09DF  0849     MOVF f1, W
09E0  07CC     ADDWF lval, F
09E1  084A     MOVF 0x4A, W
09E2  3DCD     ADDWFC 0x4D, F
09E3  084B     MOVF sign1, W
09E4  3DCE     ADDWFC 0x4E, F
141:           	if(f2_as_mant2 & 0x800000UL) {
09E5  1FCE     BTFSS 0x4E, 0x7
09E6  29F9     GOTO 0x1F9
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
09E7  30FF     MOVLW 0xFF
09E8  06CC     XORWF lval, F
09E9  30FF     MOVLW 0xFF
09EA  06CD     XORWF 0x4D, F
09EB  30FF     MOVLW 0xFF
09EC  06CE     XORWF 0x4E, F
143:           		f2_as_mant2++;
09ED  3001     MOVLW 0x1
09EE  07CC     ADDWF lval, F
09EF  3000     MOVLW 0x0
09F0  1803     BTFSC STATUS, 0x0
09F1  3001     MOVLW 0x1
09F2  07CD     ADDWF 0x4D, F
09F3  3000     MOVLW 0x0
09F4  1803     BTFSC STATUS, 0x0
09F5  3001     MOVLW 0x1
09F6  07CE     ADDWF 0x4E, F
144:           		sign = 1;
09F7  01D3     CLRF sign
09F8  0AD3     INCF sign, F
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
09F9  084C     MOVF lval, W
09FA  00F0     MOVWF __pcstackCOMMON
09FB  084D     MOVF 0x4D, W
09FC  00F1     MOVWF c
09FD  084E     MOVF 0x4E, W
09FE  00F2     MOVWF dividend
09FF  0855     MOVF exp1, W
0A00  00CF     MOVWF 0x4F
0A01  084F     MOVF 0x4F, W
0A02  00F3     MOVWF exp
0A03  0853     MOVF sign, W
0A04  00D0     MOVWF exp1
0A05  0850     MOVF exp1, W
0A06  00F4     MOVWF sign
0A07  3188     MOVLP 0x8
0A08  201C     CALL 0x1C
0A09  0870     MOVF __pcstackCOMMON, W
0A0A  0020     MOVLB 0x0
0A0B  00C9     MOVWF f1
0A0C  0871     MOVF c, W
0A0D  00CA     MOVWF 0x4A
0A0E  0872     MOVF dividend, W
0A0F  00CB     MOVWF sign1
147:           
148:           }
0A10  0008     RETURN
149:           #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/float.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(__uint24 * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(__uint24 * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (__uint24)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(__uint24 arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
081C  0873     MOVF exp, W
081D  1903     BTFSC STATUS, 0x2
081E  2824     GOTO 0x24
081F  0872     MOVF dividend, W
0820  0471     IORWF c, W
0821  0470     IORWF __pcstackCOMMON, W
0822  1D03     BTFSS STATUS, 0x2
0823  2835     GOTO 0x35
65:            		return 0.0;
0824  3000     MOVLW 0x0
0825  00F0     MOVWF __pcstackCOMMON
0826  3000     MOVLW 0x0
0827  00F1     MOVWF c
0828  3000     MOVLW 0x0
0829  00F2     MOVWF dividend
082A  0008     RETURN
66:            	while(arg & 0xFE0000UL) {
0835  30FE     MOVLW 0xFE
0836  0572     ANDWF dividend, W
0837  1903     BTFSC STATUS, 0x2
0838  284E     GOTO 0x4E
0839  282B     GOTO 0x2B
67:            		exp++;
082B  3001     MOVLW 0x1
082C  00F5     MOVWF rem
082D  0875     MOVF rem, W
082E  07F3     ADDWF exp, F
68:            		arg >>= 1;
082F  3001     MOVLW 0x1
0830  36F2     LSRF dividend, F
0831  0CF1     RRF c, F
0832  0CF0     RRF __pcstackCOMMON, F
0833  0B89     DECFSZ WREG, F
0834  2830     GOTO 0x30
69:            	}
70:            	while(arg & 0xFF0000UL) {
71:            		exp++;
083A  3001     MOVLW 0x1
083B  00F5     MOVWF rem
083C  0875     MOVF rem, W
083D  07F3     ADDWF exp, F
72:            		(arg)++;
083E  3001     MOVLW 0x1
083F  07F0     ADDWF __pcstackCOMMON, F
0840  3000     MOVLW 0x0
0841  1803     BTFSC STATUS, 0x0
0842  3001     MOVLW 0x1
0843  07F1     ADDWF c, F
0844  3000     MOVLW 0x0
0845  1803     BTFSC STATUS, 0x0
0846  3001     MOVLW 0x1
0847  07F2     ADDWF dividend, F
73:            		arg >>= 1;
0848  3001     MOVLW 0x1
0849  36F2     LSRF dividend, F
084A  0CF1     RRF c, F
084B  0CF0     RRF __pcstackCOMMON, F
084C  0B89     DECFSZ WREG, F
084D  2849     GOTO 0x49
74:            	}
084E  30FF     MOVLW 0xFF
084F  0572     ANDWF dividend, W
0850  1903     BTFSC STATUS, 0x2
0851  285F     GOTO 0x5F
0852  283A     GOTO 0x3A
75:            	while(!(arg & 0x8000UL) && exp > 1) {
0853  3002     MOVLW 0x2
0854  0273     SUBWF exp, W
0855  1C03     BTFSS STATUS, 0x0
0856  2861     GOTO 0x61
085F  1FF1     BTFSS c, 0x7
0860  2853     GOTO 0x53
76:            		exp--;
0857  3001     MOVLW 0x1
0858  02F3     SUBWF exp, F
77:            		arg <<= 1;
0859  3001     MOVLW 0x1
085A  35F0     LSLF __pcstackCOMMON, F
085B  0DF1     RLF c, F
085C  0DF2     RLF dividend, F
085D  0B89     DECFSZ WREG, F
085E  285A     GOTO 0x5A
78:            	}
79:            	if(!(exp & 1))
0861  1873     BTFSC exp, 0x0
0862  2869     GOTO 0x69
80:            		arg &= ~0x8000L;
0863  30FF     MOVLW 0xFF
0864  05F0     ANDWF __pcstackCOMMON, F
0865  307F     MOVLW 0x7F
0866  05F1     ANDWF c, F
0867  30FF     MOVLW 0xFF
0868  05F2     ANDWF dividend, F
81:            	exp >>= 1;
0869  1003     BCF STATUS, 0x0
086A  0CF3     RRF exp, F
82:            	arg |= (__uint24)exp << 16;
086B  0873     MOVF exp, W
086C  00F5     MOVWF rem
086D  01F6     CLRF divisor
086E  01F7     CLRF divisor
086F  3010     MOVLW 0x10
0870  35F5     LSLF rem, F
0871  0DF6     RLF divisor, F
0872  0DF7     RLF divisor, F
0873  0B89     DECFSZ WREG, F
0874  2870     GOTO 0x70
0875  0875     MOVF rem, W
0876  04F0     IORWF __pcstackCOMMON, F
0877  0876     MOVF divisor, W
0878  04F1     IORWF c, F
0879  0877     MOVF divisor, W
087A  04F2     IORWF dividend, F
83:            	if (sign)
087B  0874     MOVF sign, W
087C  1903     BTFSC STATUS, 0x2
087D  0008     RETURN
84:            		arg |= 0x800000UL;
087E  17F2     BSF dividend, 0x7
85:               return *(float*)&arg;	
86:            }
087F  0008     RETURN
87:            
88:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/fldivl.c  ------------------------
1:             
2:             
3:             /*	Floating point routines.
4:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
5:             
6:             	divide two floats, convert the result directly to an unsigned long
7:             
8:             */
9:             
10:            // this is bigendian code right now. Need to parameterise it.
11:            
12:            #include	"flarith.h"
13:            
14:            #define	f1_as_dividend	(*(unsigned long *)&f1)
15:            #define	f2_as_divisor	(*(unsigned long *)&f2)
16:            #ifdef _OLDLIB
17:            unsigned long int
18:            _div_to_l_(double f1, double f2)
19:            {
20:            	unsigned char	cntr, exp1;
21:            	unsigned long	quot;
22:            	
23:            	quot = 0;
24:            	__flunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return quot;
27:            	__flunpack(&f2_as_divisor, &cntr);
28:            	if(cntr == 0)
29:            		return quot;
30:            	exp1 -= 127;
31:            	exp1 -= cntr-127+31;	// compute new exponent
32:            	cntr = 32;
33:            	do {
34:            		quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	if((signed char)exp1 < 0) {
42:            		if((signed char)exp1 < -31)
43:            			return 0;
44:            		do
45:            			quot >>= 1;
46:            		while(++exp1 != 0);
47:            	} else {
48:            		if(exp1 >= 32)
49:            			return 0;
50:            		while(exp1 != 0) {
51:            			quot <<= 1;
52:            			exp1--;
53:            		}
54:            	}
55:            	return quot;
56:            }
57:            #else
58:            #define	exp2			cntr
59:            unsigned long int
60:            _div_to_l_(double f1, double f2)
61:            {
62:            	unsigned char	cntr, exp1;
63:            	unsigned long	quot;
64:            	
65:            	// unpack the operands
66:            	if((exp1 = f1_as_dividend >> 23) == 0)
0A11  3070     MOVLW 0x70
0A12  0086     MOVWF FSR1
0A13  0187     CLRF FSR1H
0A14  3F40     MOVIW 0[FSR1]
0A15  00F6     MOVWF divisor
0A16  3F41     MOVIW 1[FSR1]
0A17  00F7     MOVWF divisor
0A18  3F42     MOVIW 2[FSR1]
0A19  00F8     MOVWF c
0A1A  3F43     MOVIW 3[FSR1]
0A1B  00F9     MOVWF counter
0A1C  1003     BCF STATUS, 0x0
0A1D  0D78     RLF c, W
0A1E  0D79     RLF counter, W
0A1F  00FA     MOVWF quotient
0A20  087A     MOVF quotient, W
0A21  0020     MOVLB 0x0
0A22  00A5     MOVWF exp1
0A23  0825     MOVF exp1, W
0A24  1D03     BTFSS STATUS, 0x2
0A25  2A2F     GOTO 0x22F
67:            		return 0;
0A26  3000     MOVLW 0x0
0A27  00F3     MOVWF exp
0A28  3000     MOVLW 0x0
0A29  00F2     MOVWF dividend
0A2A  3000     MOVLW 0x0
0A2B  00F1     MOVWF c
0A2C  3000     MOVLW 0x0
0A2D  00F0     MOVWF __pcstackCOMMON
0A2E  0008     RETURN
68:            	if((exp2 = f2_as_divisor >> 23) == 0)
0A2F  3073     MOVLW 0x73
0A30  0086     MOVWF FSR1
0A31  0187     CLRF FSR1H
0A32  3F40     MOVIW 0[FSR1]
0A33  00F6     MOVWF divisor
0A34  3F41     MOVIW 1[FSR1]
0A35  00F7     MOVWF divisor
0A36  3F42     MOVIW 2[FSR1]
0A37  00F8     MOVWF c
0A38  3F43     MOVIW 3[FSR1]
0A39  00F9     MOVWF counter
0A3A  1003     BCF STATUS, 0x0
0A3B  0D78     RLF c, W
0A3C  0D79     RLF counter, W
0A3D  00FA     MOVWF quotient
0A3E  087A     MOVF quotient, W
0A3F  00A4     MOVWF multiplier
0A40  0824     MOVF multiplier, W
0A41  1903     BTFSC STATUS, 0x2
0A42  2A26     GOTO 0x226
69:            		return 0;
70:            	f1_as_dividend |= 0x800000UL;
0A43  3070     MOVLW 0x70
0A44  0086     MOVWF FSR1
0A45  0187     CLRF FSR1H
0A46  3000     MOVLW 0x0
0A47  0481     IORWF INDF1, F
0A48  3141     ADDFSR 1, 1
0A49  3000     MOVLW 0x0
0A4A  0481     IORWF INDF1, F
0A4B  3141     ADDFSR 1, 1
0A4C  3080     MOVLW 0x80
0A4D  0481     IORWF INDF1, F
0A4E  3141     ADDFSR 1, 1
0A4F  3000     MOVLW 0x0
0A50  0481     IORWF INDF1, F
71:            	f1_as_dividend &= 0xFFFFFFUL;
0A51  3070     MOVLW 0x70
0A52  0086     MOVWF FSR1
0A53  0187     CLRF FSR1H
0A54  30FF     MOVLW 0xFF
0A55  0581     ANDWF INDF1, F
0A56  3141     ADDFSR 1, 1
0A57  30FF     MOVLW 0xFF
0A58  0581     ANDWF INDF1, F
0A59  3141     ADDFSR 1, 1
0A5A  30FF     MOVLW 0xFF
0A5B  0581     ANDWF INDF1, F
0A5C  3141     ADDFSR 1, 1
0A5D  3000     MOVLW 0x0
0A5E  0581     ANDWF INDF1, F
72:            	f2_as_divisor |= 0x800000UL;
0A5F  3073     MOVLW 0x73
0A60  0086     MOVWF FSR1
0A61  0187     CLRF FSR1H
0A62  3000     MOVLW 0x0
0A63  0481     IORWF INDF1, F
0A64  3141     ADDFSR 1, 1
0A65  3000     MOVLW 0x0
0A66  0481     IORWF INDF1, F
0A67  3141     ADDFSR 1, 1
0A68  3080     MOVLW 0x80
0A69  0481     IORWF INDF1, F
0A6A  3141     ADDFSR 1, 1
0A6B  3000     MOVLW 0x0
0A6C  0481     IORWF INDF1, F
73:            	f2_as_divisor &= 0xFFFFFFUL;
0A6D  3073     MOVLW 0x73
0A6E  0086     MOVWF FSR1
0A6F  0187     CLRF FSR1H
0A70  30FF     MOVLW 0xFF
0A71  0581     ANDWF INDF1, F
0A72  3141     ADDFSR 1, 1
0A73  30FF     MOVLW 0xFF
0A74  0581     ANDWF INDF1, F
0A75  3141     ADDFSR 1, 1
0A76  30FF     MOVLW 0xFF
0A77  0581     ANDWF INDF1, F
0A78  3141     ADDFSR 1, 1
0A79  3000     MOVLW 0x0
0A7A  0581     ANDWF INDF1, F
74:            	quot = 0;
0A7B  3000     MOVLW 0x0
0A7C  00A3     MOVWF 0x23
0A7D  3000     MOVLW 0x0
0A7E  00A2     MOVWF quotient
0A7F  3000     MOVLW 0x0
0A80  00A1     MOVWF sign
0A81  3000     MOVLW 0x0
0A82  00A0     MOVWF __pcstackBANK0
75:            	exp1 -= 127;
0A83  307F     MOVLW 0x7F
0A84  02A5     SUBWF exp1, F
76:            	exp1 -= cntr-127+31;	// compute new exponent
0A85  30A0     MOVLW 0xA0
0A86  0724     ADDWF multiplier, W
0A87  00F6     MOVWF divisor
0A88  0876     MOVF divisor, W
0A89  02A5     SUBWF exp1, F
77:            	cntr = 32;
0A8A  3020     MOVLW 0x20
0A8B  00F6     MOVWF divisor
0A8C  0876     MOVF divisor, W
0A8D  00A4     MOVWF multiplier
78:            	do {
79:            		quot <<= 1;
0A8E  3001     MOVLW 0x1
0A8F  35A0     LSLF __pcstackBANK0, F
0A90  0DA1     RLF sign, F
0A91  0DA2     RLF quotient, F
0A92  0DA3     RLF 0x23, F
0A93  0B89     DECFSZ WREG, F
0A94  2A8F     GOTO 0x28F
80:            		if(f1_as_dividend >= f2_as_divisor) {
0A95  3073     MOVLW 0x73
0A96  0086     MOVWF FSR1
0A97  0187     CLRF FSR1H
0A98  3F40     MOVIW 0[FSR1]
0A99  00F6     MOVWF divisor
0A9A  3F41     MOVIW 1[FSR1]
0A9B  00F7     MOVWF divisor
0A9C  3F42     MOVIW 2[FSR1]
0A9D  00F8     MOVWF c
0A9E  3F43     MOVIW 3[FSR1]
0A9F  00F9     MOVWF counter
0AA0  3070     MOVLW 0x70
0AA1  0086     MOVWF FSR1
0AA2  0187     CLRF FSR1H
0AA3  3F40     MOVIW 0[FSR1]
0AA4  00FA     MOVWF quotient
0AA5  3F41     MOVIW 1[FSR1]
0AA6  00FB     MOVWF c
0AA7  3F42     MOVIW 2[FSR1]
0AA8  00FC     MOVWF product
0AA9  3F43     MOVIW 3[FSR1]
0AAA  00FD     MOVWF exp
0AAB  0879     MOVF counter, W
0AAC  027D     SUBWF exp, W
0AAD  1D03     BTFSS STATUS, 0x2
0AAE  2AB9     GOTO 0x2B9
0AAF  0878     MOVF c, W
0AB0  027C     SUBWF product, W
0AB1  1D03     BTFSS STATUS, 0x2
0AB2  2AB9     GOTO 0x2B9
0AB3  0877     MOVF divisor, W
0AB4  027B     SUBWF c, W
0AB5  1D03     BTFSS STATUS, 0x2
0AB6  2AB9     GOTO 0x2B9
0AB7  0876     MOVF divisor, W
0AB8  027A     SUBWF quotient, W
0AB9  1C03     BTFSS STATUS, 0x0
0ABA  2AD6     GOTO 0x2D6
81:            			f1_as_dividend -= f2_as_divisor;
0ABB  3073     MOVLW 0x73
0ABC  0086     MOVWF FSR1
0ABD  0187     CLRF FSR1H
0ABE  3F40     MOVIW 0[FSR1]
0ABF  00F6     MOVWF divisor
0AC0  3F41     MOVIW 1[FSR1]
0AC1  00F7     MOVWF divisor
0AC2  3F42     MOVIW 2[FSR1]
0AC3  00F8     MOVWF c
0AC4  3F43     MOVIW 3[FSR1]
0AC5  00F9     MOVWF counter
0AC6  3070     MOVLW 0x70
0AC7  0086     MOVWF FSR1
0AC8  0187     CLRF FSR1H
0AC9  0876     MOVF divisor, W
0ACA  0281     SUBWF INDF1, F
0ACB  3141     ADDFSR 1, 1
0ACC  0877     MOVF divisor, W
0ACD  3B81     SUBWFB INDF1, F
0ACE  3141     ADDFSR 1, 1
0ACF  0878     MOVF c, W
0AD0  3B81     SUBWFB INDF1, F
0AD1  3141     ADDFSR 1, 1
0AD2  0879     MOVF counter, W
0AD3  3B81     SUBWFB INDF1, F
0AD4  317D     ADDFSR 1, -3
82:            			quot |= 1;
0AD5  1420     BSF __pcstackBANK0, 0x0
83:            		}
84:            		f1_as_dividend <<= 1;
0AD6  3070     MOVLW 0x70
0AD7  0086     MOVWF FSR1
0AD8  0187     CLRF FSR1H
0AD9  3581     LSLF INDF1, F
0ADA  3141     ADDFSR 1, 1
0ADB  0D81     RLF INDF1, F
0ADC  3141     ADDFSR 1, 1
0ADD  0D81     RLF INDF1, F
0ADE  3141     ADDFSR 1, 1
0ADF  0D81     RLF INDF1, F
0AE0  317D     ADDFSR 1, -3
85:            	} while(--cntr != 0);
0AE1  3001     MOVLW 0x1
0AE2  02A4     SUBWF multiplier, F
0AE3  1D03     BTFSS STATUS, 0x2
0AE4  2A8E     GOTO 0x28E
86:            	if((signed char)exp1 < 0) {
0AE5  1FA5     BTFSS exp1, 0x7
0AE6  2AFA     GOTO 0x2FA
87:            		if((signed char)exp1 < -31)
0AE7  0825     MOVF exp1, W
0AE8  3A80     XORLW 0x80
0AE9  3E9F     ADDLW 0x9F
0AEA  1C03     BTFSS STATUS, 0x0
0AEB  2A26     GOTO 0x226
88:            			return 0;
89:            		do
90:            			quot >>= 1;
0AEC  3001     MOVLW 0x1
0AED  36A3     LSRF 0x23, F
0AEE  0CA2     RRF quotient, F
0AEF  0CA1     RRF sign, F
0AF0  0CA0     RRF __pcstackBANK0, F
0AF1  0B89     DECFSZ WREG, F
0AF2  2AED     GOTO 0x2ED
91:            		while(++exp1 != 0);
0AF3  3001     MOVLW 0x1
0AF4  00F6     MOVWF divisor
0AF5  0876     MOVF divisor, W
0AF6  07A5     ADDWF exp1, F
0AF7  1903     BTFSC STATUS, 0x2
0AF8  2B0B     GOTO 0x30B
0AF9  2AEC     GOTO 0x2EC
92:            	} else {
93:            		if(exp1 >= 32)
0AFA  3020     MOVLW 0x20
0AFB  0225     SUBWF exp1, W
0AFC  1803     BTFSC STATUS, 0x0
0AFD  2A26     GOTO 0x226
94:            			return 0;
95:            		while(exp1 != 0) {
0B0A  2AFE     GOTO 0x2FE
96:            			quot <<= 1;
0B01  3001     MOVLW 0x1
0B02  35A0     LSLF __pcstackBANK0, F
0B03  0DA1     RLF sign, F
0B04  0DA2     RLF quotient, F
0B05  0DA3     RLF 0x23, F
0B06  0B89     DECFSZ WREG, F
0B07  2B02     GOTO 0x302
97:            			exp1--;
0B08  3001     MOVLW 0x1
0B09  02A5     SUBWF exp1, F
98:            		}
0AFE  0825     MOVF exp1, W
0AFF  1903     BTFSC STATUS, 0x2
0B00  2B0B     GOTO 0x30B
99:            	}
100:           	return quot;
0B0B  0823     MOVF 0x23, W
0B0C  00F3     MOVWF exp
0B0D  0822     MOVF quotient, W
0B0E  00F2     MOVWF dividend
0B0F  0821     MOVF sign, W
0B10  00F1     MOVWF c
0B11  0820     MOVF __pcstackBANK0, W
0B12  00F0     MOVWF __pcstackCOMMON
101:           }
0B13  0008     RETURN
102:           #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/doprnt.c  ------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<math.h>
8:             #include	<float.h>
9:             
10:            // disable unused variable warnings
11:            // the compiler will optimize them away, so no harm is done
12:            #pragma warning disable 350
13:            
14:            /*
15:             *	doprnt - versions depends on conditional compilation.
16:             *	Can be customized with defines.
17:             *
18:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
19:             *
20:             *	$Header$
21:             *
22:             */
23:            
24:            #ifndef	CUSTOM_PRINTF
25:            
26:             // define all flags, thus enabling all features
27:            
28:            #define	BASEM	0xC0
29:            #define	OPTSIGN	0x00
30:            #define	SPCSIGN	0x01
31:            #define	MANSIGN	0x02
32:            #define	NEGSIGN	0x03
33:            #define	FILL	0x04
34:            #define	LEFT	0x08
35:            #define	LONG	0x10
36:            #define	LONGLONG	0x4000000
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	__far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(__SIZEOF_LONG__ == __SIZEOF_INT__ || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if (__SIZEOF_LONG__ > 4)
262:           #define __LONGLONG	1
263:           #endif
264:           
265:           #if	__SIZEOF_DOUBLE__ == __SIZEOF_LONG__ && DBL_MAX_EXP == 128
266:           #undef	frexp
267:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
268:           #elif	defined(_PSOC_)
269:           #undef	frexp
270:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(__uint24 *)&val >> 15)) - 126)
271:           #elif	__SIZEOF_DOUBLE__ == 3 && DBL_MAX_EXP == 128
272:           #undef	frexp
273:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
274:           #endif
275:           
276:           #if	defined(__FLOAT) && __SIZEOF_DOUBLE__ == 8
277:           #define	DOUBLE	1
278:           
279:           extern double	_dto64i(double);
280:           extern double	_64itod(double);
281:           extern double	_div64(double, double);
282:           extern double	_divto64i(double, double);
283:           extern unsigned	_div64ir(double, double);
284:           extern unsigned	_mod64i10(double);
285:           
286:           #else
287:           #define	DOUBLE	0
288:           #endif
289:           
290:           #ifdef	__LONG
291:           #define	value	long
292:           #define	NDIG	12		/* max number of digits to be printed */
293:           #else
294:           #define	value	int
295:           #define	NDIG	6		/* max number of digits to be printed */
296:           #endif
297:           
298:           #if	DOUBLE
299:           union {
300:           	unsigned long	ul[40];
301:           	double		db[20];
302:           }	_fdp =
303:           {
304:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
305:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
306:           #endif
307:           #if	BIG_ENDIAN
308:           	0x00000000,0x00000001,
309:           	0x00000000,0x0000000A,
310:           	0x00000000,0x00000064,
311:           	0x00000000,0x000003E8,
312:           	0x00000000,0x00002710,
313:           	0x00000000,0x000186A0,
314:           	0x00000000,0x000F4240,
315:           	0x00000000,0x00989680,
316:           	0x00000000,0x05F5E100,
317:           	0x00000000,0x3B9ACA00,
318:           	0x00000002,0x540BE400,
319:           	0x00000017,0x4876E800,
320:           	0x000000E8,0xD4A51000,
321:           	0x00000918,0x4E72A000,
322:           	0x00005AF3,0x107A4000,
323:           	0x00038D7E,0xA4C68000,
324:           	0x002386F2,0x6FC10000,
325:           	0x01634578,0x5D8A0000,
326:           	0x0DE0B6B3,0xA7640000,
327:           	0x8AC72304,0x89E80000,
328:           #else
329:           	0x00000001,0x00000000,
330:           	0x0000000A,0x00000000,
331:           	0x00000064,0x00000000,
332:           	0x000003E8,0x00000000,
333:           	0x00002710,0x00000000,
334:           	0x000186A0,0x00000000,
335:           	0x000F4240,0x00000000,
336:           	0x00989680,0x00000000,
337:           	0x05F5E100,0x00000000,
338:           	0x3B9ACA00,0x00000000,
339:           	0x540BE400,0x00000002,
340:           	0x4876E800,0x00000017,
341:           	0xD4A51000,0x000000E8,
342:           	0x4E72A000,0x00000918,
343:           	0x107A4000,0x00005AF3,
344:           	0xA4C68000,0x00038D7E,
345:           	0x6FC10000,0x002386F2,
346:           	0x5D8A0000,0x01634578,
347:           	0xA7640000,0x0DE0B6B3,
348:           	0x89E80000,0x8AC72304,
349:           #endif
350:           };
351:           
352:           #define	fdpowers	_fdp.db
353:           
354:           #else
355:           #define	fdpowers	dpowers
356:           #endif
357:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
358:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
359:           #ifdef	__LONG
360:           						 100000, 1000000, 10000000, 100000000,
361:           						 1000000000
362:           #endif
363:           							 };
364:           #endif
365:           #ifdef	SIXTEEN
366:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
367:           #if	__LONG
368:           						 0x10000, 0x100000, 0x1000000, 0x10000000
369:           #endif
370:           							};
371:           #endif
372:           #ifdef	EIGHT
373:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
374:           #ifdef	__LONG
375:           						01000000,
376:           						 010000000, 0100000000, 01000000000, 010000000000,
377:           #ifdef __LONGLONG
378:           						 0100000000000
379:           #endif
380:           #endif
381:           							};
382:           #endif
383:           
384:           #ifdef	__FLOAT
385:           
386:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
387:           
388:           #if	DBL_MAX_10_EXP > 120
389:           #define	expon	int
390:           #define	uns_expon	unsigned int
391:           #else
392:           #define	expon	signed char
393:           #define	uns_expon	unsigned char
394:           #endif
395:           
396:           extern const double	_powers_[], _npowers_[];
397:           #ifdef	z80
398:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
399:           #else
400:           extern unsigned long	_div_to_l_(double, double);
401:           #ifdef	_OMNI_CODE_
402:           extern unsigned long	_tdiv_to_l_(float, float);
403:           #ifdef	_HTKC_
404:           #pragma callname _div_to_l_ double
405:           #pragma callname _tdiv_to_l_ float
406:           #endif
407:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
408:           #else
409:           #define	div_to_l_	_div_to_l_
410:           #endif
411:           #endif
412:           
413:           /* this routine returns a value to round to the number of decimal
414:           	places specified */
415:           #if __FLOAT
416:           static double
417:           fround(unsigned char prec)
0B14  0020     MOVLB 0x0
0B15  00C8     MOVWF prec
418:           {
419:           	/* prec is guaranteed to be less than NDIG */
420:           
421:           	if(prec>=110)
0B16  306E     MOVLW 0x6E
0B17  0248     SUBWF prec, W
0B18  1C03     BTFSS STATUS, 0x0
0B19  2BB7     GOTO 0x3B7
422:           		return 0.5 * _npowers_[prec/100U+18U] * _npowers_[(prec%100U)/10U+9U] * _npowers_[prec%10U];
0B1A  300A     MOVLW 0xA
0B1B  00BB     MOVWF 0x3B
0B1C  083B     MOVF 0x3B, W
0B1D  00F6     MOVWF divisor
0B1E  3064     MOVLW 0x64
0B1F  00BC     MOVWF 0x3C
0B20  083C     MOVF 0x3C, W
0B21  00F0     MOVWF __pcstackCOMMON
0B22  0848     MOVF prec, W
0B23  3193     MOVLP 0x13
0B24  233B     CALL 0x33B
0B25  318B     MOVLP 0xB
0B26  3193     MOVLP 0x13
0B27  237A     CALL 0x37A
0B28  318B     MOVLP 0xB
0B29  00BD     MOVWF 0x3D
0B2A  01BE     CLRF 0x3E
0B2B  083D     MOVF 0x3D, W
0B2C  00A4     MOVWF multiplier
0B2D  083E     MOVF 0x3E, W
0B2E  00A5     MOVWF exp1
0B2F  3003     MOVLW 0x3
0B30  00A6     MOVWF multiplicand
0B31  3000     MOVLW 0x0
0B32  00A7     MOVWF f1
0B33  3193     MOVLP 0x13
0B34  2304     CALL 0x304
0B35  318B     MOVLP 0xB
0B36  0825     MOVF exp1, W
0B37  0085     MOVWF FSR0H
0B38  0824     MOVF multiplier, W
0B39  0084     MOVWF FSR0
0B3A  306A     MOVLW 0x6A
0B3B  0784     ADDWF FSR0, F
0B3C  3098     MOVLW 0x98
0B3D  3D85     ADDWFC FSR0H, F
0B3E  3F00     MOVIW 0[FSR0]
0B3F  00A8     MOVWF f1
0B40  3F01     MOVIW 1[FSR0]
0B41  00A9     MOVWF counter
0B42  3F02     MOVIW 2[FSR0]
0B43  00AA     MOVWF exp
0B44  3064     MOVLW 0x64
0B45  00BF     MOVWF 0x3F
0B46  083F     MOVF 0x3F, W
0B47  00F6     MOVWF divisor
0B48  0848     MOVF prec, W
0B49  3193     MOVLP 0x13
0B4A  237A     CALL 0x37A
0B4B  318B     MOVLP 0xB
0B4C  00C0     MOVWF 0x40
0B4D  01C1     CLRF 0x41
0B4E  0840     MOVF 0x40, W
0B4F  00A4     MOVWF multiplier
0B50  0841     MOVF 0x41, W
0B51  00A5     MOVWF exp1
0B52  3003     MOVLW 0x3
0B53  00A6     MOVWF multiplicand
0B54  3000     MOVLW 0x0
0B55  00A7     MOVWF f1
0B56  3193     MOVLP 0x13
0B57  2304     CALL 0x304
0B58  318B     MOVLP 0xB
0B59  0825     MOVF exp1, W
0B5A  0085     MOVWF FSR0H
0B5B  0824     MOVF multiplier, W
0B5C  0084     MOVWF FSR0
0B5D  3085     MOVLW 0x85
0B5E  0784     ADDWF FSR0, F
0B5F  3098     MOVLW 0x98
0B60  3D85     ADDWFC FSR0H, F
0B61  3F00     MOVIW 0[FSR0]
0B62  00AB     MOVWF f2
0B63  3F01     MOVIW 1[FSR0]
0B64  00AC     MOVWF 0x2C
0B65  3F02     MOVIW 2[FSR0]
0B66  00AD     MOVWF 0x2D
0B67  3197     MOVLP 0x17
0B68  2765     CALL 0x765
0B69  318B     MOVLP 0xB
0B6A  0828     MOVF f1, W
0B6B  00C5     MOVWF 0x45
0B6C  0829     MOVF counter, W
0B6D  00C6     MOVWF 0x46
0B6E  082A     MOVF exp, W
0B6F  00C7     MOVWF 0x47
0B70  300A     MOVLW 0xA
0B71  00BB     MOVWF 0x3B
0B72  083B     MOVF 0x3B, W
0B73  00F0     MOVWF __pcstackCOMMON
0B74  0848     MOVF prec, W
0B75  3193     MOVLP 0x13
0B76  233B     CALL 0x33B
0B77  318B     MOVLP 0xB
0B78  00BC     MOVWF 0x3C
0B79  01BD     CLRF 0x3D
0B7A  083C     MOVF 0x3C, W
0B7B  00A4     MOVWF multiplier
0B7C  083D     MOVF 0x3D, W
0B7D  00A5     MOVWF exp1
0B7E  3003     MOVLW 0x3
0B7F  00A6     MOVWF multiplicand
0B80  3000     MOVLW 0x0
0B81  00A7     MOVWF f1
0B82  3193     MOVLP 0x13
0B83  2304     CALL 0x304
0B84  318B     MOVLP 0xB
0B85  0825     MOVF exp1, W
0B86  0085     MOVWF FSR0H
0B87  0824     MOVF multiplier, W
0B88  0084     MOVWF FSR0
0B89  304F     MOVLW 0x4F
0B8A  0784     ADDWF FSR0, F
0B8B  3098     MOVLW 0x98
0B8C  3D85     ADDWFC FSR0H, F
0B8D  3F00     MOVIW 0[FSR0]
0B8E  00A8     MOVWF f1
0B8F  3F01     MOVIW 1[FSR0]
0B90  00A9     MOVWF counter
0B91  3F02     MOVIW 2[FSR0]
0B92  00AA     MOVWF exp
0B93  0845     MOVF 0x45, W
0B94  00AB     MOVWF f2
0B95  0846     MOVF 0x46, W
0B96  00AC     MOVWF 0x2C
0B97  0847     MOVF 0x47, W
0B98  00AD     MOVWF 0x2D
0B99  3197     MOVLP 0x17
0B9A  2765     CALL 0x765
0B9B  318B     MOVLP 0xB
0B9C  0828     MOVF f1, W
0B9D  00C2     MOVWF scl
0B9E  0829     MOVF counter, W
0B9F  00C3     MOVWF f1
0BA0  082A     MOVF exp, W
0BA1  00C4     MOVWF 0x44
0BA2  3000     MOVLW 0x0
0BA3  00A8     MOVWF f1
0BA4  3000     MOVLW 0x0
0BA5  00A9     MOVWF counter
0BA6  303F     MOVLW 0x3F
0BA7  00AA     MOVWF exp
0BA8  0842     MOVF scl, W
0BA9  00AB     MOVWF f2
0BAA  0843     MOVF f1, W
0BAB  00AC     MOVWF 0x2C
0BAC  0844     MOVF 0x44, W
0BAD  00AD     MOVWF 0x2D
0BAE  3197     MOVLP 0x17
0BAF  2765     CALL 0x765
0BB0  0828     MOVF f1, W
0BB1  00B8     MOVWF 0x38
0BB2  0829     MOVF counter, W
0BB3  00B9     MOVWF 0x39
0BB4  082A     MOVF exp, W
0BB5  00BA     MOVWF 0x3A
0BB6  0008     RETURN
423:           	else if(prec > 10)
0BB7  300B     MOVLW 0xB
0BB8  0248     SUBWF prec, W
0BB9  1C03     BTFSS STATUS, 0x0
0BBA  2C1F     GOTO 0x41F
424:           		return 0.5 * _npowers_[prec/10U+9U] * _npowers_[prec%10U];
0BBB  300A     MOVLW 0xA
0BBC  00BB     MOVWF 0x3B
0BBD  083B     MOVF 0x3B, W
0BBE  00F0     MOVWF __pcstackCOMMON
0BBF  0848     MOVF prec, W
0BC0  3193     MOVLP 0x13
0BC1  233B     CALL 0x33B
0BC2  318B     MOVLP 0xB
0BC3  00BC     MOVWF 0x3C
0BC4  01BD     CLRF 0x3D
0BC5  083C     MOVF 0x3C, W
0BC6  00A4     MOVWF multiplier
0BC7  083D     MOVF 0x3D, W
0BC8  00A5     MOVWF exp1
0BC9  3003     MOVLW 0x3
0BCA  00A6     MOVWF multiplicand
0BCB  3000     MOVLW 0x0
0BCC  00A7     MOVWF f1
0BCD  3193     MOVLP 0x13
0BCE  2304     CALL 0x304
0BCF  318B     MOVLP 0xB
0BD0  0825     MOVF exp1, W
0BD1  0085     MOVWF FSR0H
0BD2  0824     MOVF multiplier, W
0BD3  0084     MOVWF FSR0
0BD4  304F     MOVLW 0x4F
0BD5  0784     ADDWF FSR0, F
0BD6  3098     MOVLW 0x98
0BD7  3D85     ADDWFC FSR0H, F
0BD8  3F00     MOVIW 0[FSR0]
0BD9  00A8     MOVWF f1
0BDA  3F01     MOVIW 1[FSR0]
0BDB  00A9     MOVWF counter
0BDC  3F02     MOVIW 2[FSR0]
0BDD  00AA     MOVWF exp
0BDE  300A     MOVLW 0xA
0BDF  00BE     MOVWF 0x3E
0BE0  083E     MOVF 0x3E, W
0BE1  00F6     MOVWF divisor
0BE2  0848     MOVF prec, W
0BE3  3193     MOVLP 0x13
0BE4  237A     CALL 0x37A
0BE5  318B     MOVLP 0xB
0BE6  00BF     MOVWF 0x3F
0BE7  01C0     CLRF 0x40
0BE8  083F     MOVF 0x3F, W
0BE9  00A4     MOVWF multiplier
0BEA  0840     MOVF 0x40, W
0BEB  00A5     MOVWF exp1
0BEC  3003     MOVLW 0x3
0BED  00A6     MOVWF multiplicand
0BEE  3000     MOVLW 0x0
0BEF  00A7     MOVWF f1
0BF0  3193     MOVLP 0x13
0BF1  2304     CALL 0x304
0BF2  318B     MOVLP 0xB
0BF3  0825     MOVF exp1, W
0BF4  0085     MOVWF FSR0H
0BF5  0824     MOVF multiplier, W
0BF6  0084     MOVWF FSR0
0BF7  306A     MOVLW 0x6A
0BF8  0784     ADDWF FSR0, F
0BF9  3098     MOVLW 0x98
0BFA  3D85     ADDWFC FSR0H, F
0BFB  3F00     MOVIW 0[FSR0]
0BFC  00AB     MOVWF f2
0BFD  3F01     MOVIW 1[FSR0]
0BFE  00AC     MOVWF 0x2C
0BFF  3F02     MOVIW 2[FSR0]
0C00  00AD     MOVWF 0x2D
0C01  3197     MOVLP 0x17
0C02  2765     CALL 0x765
0C03  318B     MOVLP 0xB
0C04  0828     MOVF f1, W
0C05  00C5     MOVWF 0x45
0C06  0829     MOVF counter, W
0C07  00C6     MOVWF 0x46
0C08  082A     MOVF exp, W
0C09  00C7     MOVWF 0x47
0C0A  3000     MOVLW 0x0
0C0B  00A8     MOVWF f1
0C0C  3000     MOVLW 0x0
0C0D  00A9     MOVWF counter
0C0E  303F     MOVLW 0x3F
0C0F  00AA     MOVWF exp
0C10  0845     MOVF 0x45, W
0C11  00AB     MOVWF f2
0C12  0846     MOVF 0x46, W
0C13  00AC     MOVWF 0x2C
0C14  0847     MOVF 0x47, W
0C15  00AD     MOVWF 0x2D
0C16  3197     MOVLP 0x17
0C17  2765     CALL 0x765
0C18  0828     MOVF f1, W
0C19  00B8     MOVWF 0x38
0C1A  0829     MOVF counter, W
0C1B  00B9     MOVWF 0x39
0C1C  082A     MOVF exp, W
0C1D  00BA     MOVWF 0x3A
0C1E  0008     RETURN
425:           	return 0.5 * _npowers_[prec];
0C1F  3000     MOVLW 0x0
0C20  00A8     MOVWF f1
0C21  3000     MOVLW 0x0
0C22  00A9     MOVWF counter
0C23  303F     MOVLW 0x3F
0C24  00AA     MOVWF exp
0C25  0848     MOVF prec, W
0C26  00BB     MOVWF 0x3B
0C27  01BC     CLRF 0x3C
0C28  083B     MOVF 0x3B, W
0C29  00A4     MOVWF multiplier
0C2A  083C     MOVF 0x3C, W
0C2B  00A5     MOVWF exp1
0C2C  3003     MOVLW 0x3
0C2D  00A6     MOVWF multiplicand
0C2E  3000     MOVLW 0x0
0C2F  00A7     MOVWF f1
0C30  3193     MOVLP 0x13
0C31  2304     CALL 0x304
0C32  318B     MOVLP 0xB
0C33  0825     MOVF exp1, W
0C34  0085     MOVWF FSR0H
0C35  0824     MOVF multiplier, W
0C36  0084     MOVWF FSR0
0C37  304F     MOVLW 0x4F
0C38  0784     ADDWF FSR0, F
0C39  3098     MOVLW 0x98
0C3A  3D85     ADDWFC FSR0H, F
0C3B  3F00     MOVIW 0[FSR0]
0C3C  00AB     MOVWF f2
0C3D  3F01     MOVIW 1[FSR0]
0C3E  00AC     MOVWF 0x2C
0C3F  3F02     MOVIW 2[FSR0]
0C40  00AD     MOVWF 0x2D
0C41  3197     MOVLP 0x17
0C42  2765     CALL 0x765
0C43  0828     MOVF f1, W
0C44  00B8     MOVWF 0x38
0C45  0829     MOVF counter, W
0C46  00B9     MOVWF 0x39
0C47  082A     MOVF exp, W
0C48  00BA     MOVWF 0x3A
426:           }
0C49  0008     RETURN
427:           #endif
428:           
429:           /* this routine returns a scaling factor equal to 1 to the decimal
430:              power supplied */
431:           
432:           static double
433:           scale(expon scl)
0084  0020     MOVLB 0x0
0085  00C2     MOVWF scl
434:           {
435:           
436:           	if(scl < 0) {
0086  1FC2     BTFSS scl, 0x7
0087  29A7     GOTO 0x1A7
437:           		scl = -scl;
0088  09C2     COMF scl, F
0089  0AC2     INCF scl, F
438:           		if(scl>=110)
008A  0842     MOVF scl, W
008B  3A80     XORLW 0x80
008C  3E12     ADDLW 0x12
008D  1C03     BTFSS STATUS, 0x0
008E  292C     GOTO 0x12C
439:           			return _npowers_[(uns_expon)(scl/100+18)] * _npowers_[(uns_expon)((scl%100)/10+9)] * _npowers_[(uns_expon)(scl%10)];
008F  0842     MOVF scl, W
0090  00F2     MOVWF dividend
0091  01F3     CLRF exp
0092  1BF2     BTFSC dividend, 0x7
0093  03F3     DECF exp, F
0094  3064     MOVLW 0x64
0095  00F0     MOVWF __pcstackCOMMON
0096  3000     MOVLW 0x0
0097  00F1     MOVWF c
0098  3194     MOVLP 0x14
0099  249E     CALL 0x49E
009A  3180     MOVLP 0x0
009B  0871     MOVF c, W
009C  00FA     MOVWF quotient
009D  0870     MOVF __pcstackCOMMON, W
009E  00F9     MOVWF counter
009F  300A     MOVLW 0xA
00A0  00F7     MOVWF divisor
00A1  3000     MOVLW 0x0
00A2  00F8     MOVWF c
00A3  3195     MOVLP 0x15
00A4  25D5     CALL 0x5D5
00A5  3180     MOVLP 0x0
00A6  0877     MOVF divisor, W
00A7  3E09     ADDLW 0x9
00A8  00BB     MOVWF 0x3B
00A9  01BC     CLRF 0x3C
00AA  083B     MOVF 0x3B, W
00AB  00A4     MOVWF multiplier
00AC  083C     MOVF 0x3C, W
00AD  00A5     MOVWF exp1
00AE  3003     MOVLW 0x3
00AF  00A6     MOVWF multiplicand
00B0  3000     MOVLW 0x0
00B1  00A7     MOVWF f1
00B2  3193     MOVLP 0x13
00B3  2304     CALL 0x304
00B4  3180     MOVLP 0x0
00B5  0825     MOVF exp1, W
00B6  0085     MOVWF FSR0H
00B7  0824     MOVF multiplier, W
00B8  0084     MOVWF FSR0
00B9  304F     MOVLW 0x4F
00BA  0784     ADDWF FSR0, F
00BB  3098     MOVLW 0x98
00BC  3D85     ADDWFC FSR0H, F
00BD  3F00     MOVIW 0[FSR0]
00BE  00A8     MOVWF f1
00BF  3F01     MOVIW 1[FSR0]
00C0  00A9     MOVWF counter
00C1  3F02     MOVIW 2[FSR0]
00C2  00AA     MOVWF exp
00C3  0842     MOVF scl, W
00C4  00F9     MOVWF counter
00C5  01FA     CLRF quotient
00C6  1BF9     BTFSC counter, 0x7
00C7  03FA     DECF quotient, F
00C8  3064     MOVLW 0x64
00C9  00F7     MOVWF divisor
00CA  3000     MOVLW 0x0
00CB  00F8     MOVWF c
00CC  3195     MOVLP 0x15
00CD  25D5     CALL 0x5D5
00CE  3180     MOVLP 0x0
00CF  0877     MOVF divisor, W
00D0  3E12     ADDLW 0x12
00D1  00BD     MOVWF 0x3D
00D2  01BE     CLRF 0x3E
00D3  083D     MOVF 0x3D, W
00D4  00A4     MOVWF multiplier
00D5  083E     MOVF 0x3E, W
00D6  00A5     MOVWF exp1
00D7  3003     MOVLW 0x3
00D8  00A6     MOVWF multiplicand
00D9  3000     MOVLW 0x0
00DA  00A7     MOVWF f1
00DB  3193     MOVLP 0x13
00DC  2304     CALL 0x304
00DD  3180     MOVLP 0x0
00DE  0825     MOVF exp1, W
00DF  0085     MOVWF FSR0H
00E0  0824     MOVF multiplier, W
00E1  0084     MOVWF FSR0
00E2  304F     MOVLW 0x4F
00E3  0784     ADDWF FSR0, F
00E4  3098     MOVLW 0x98
00E5  3D85     ADDWFC FSR0H, F
00E6  3F00     MOVIW 0[FSR0]
00E7  00AB     MOVWF f2
00E8  3F01     MOVIW 1[FSR0]
00E9  00AC     MOVWF 0x2C
00EA  3F02     MOVIW 2[FSR0]
00EB  00AD     MOVWF 0x2D
00EC  3197     MOVLP 0x17
00ED  2765     CALL 0x765
00EE  3180     MOVLP 0x0
00EF  0828     MOVF f1, W
00F0  00BF     MOVWF 0x3F
00F1  0829     MOVF counter, W
00F2  00C0     MOVWF 0x40
00F3  082A     MOVF exp, W
00F4  00C1     MOVWF 0x41
00F5  0842     MOVF scl, W
00F6  00F2     MOVWF dividend
00F7  01F3     CLRF exp
00F8  1BF2     BTFSC dividend, 0x7
00F9  03F3     DECF exp, F
00FA  300A     MOVLW 0xA
00FB  00F0     MOVWF __pcstackCOMMON
00FC  3000     MOVLW 0x0
00FD  00F1     MOVWF c
00FE  3194     MOVLP 0x14
00FF  249E     CALL 0x49E
0100  3180     MOVLP 0x0
0101  0870     MOVF __pcstackCOMMON, W
0102  00BB     MOVWF 0x3B
0103  01BC     CLRF 0x3C
0104  083B     MOVF 0x3B, W
0105  00A4     MOVWF multiplier
0106  083C     MOVF 0x3C, W
0107  00A5     MOVWF exp1
0108  3003     MOVLW 0x3
0109  00A6     MOVWF multiplicand
010A  3000     MOVLW 0x0
010B  00A7     MOVWF f1
010C  3193     MOVLP 0x13
010D  2304     CALL 0x304
010E  3180     MOVLP 0x0
010F  0825     MOVF exp1, W
0110  0085     MOVWF FSR0H
0111  0824     MOVF multiplier, W
0112  0084     MOVWF FSR0
0113  304F     MOVLW 0x4F
0114  0784     ADDWF FSR0, F
0115  3098     MOVLW 0x98
0116  3D85     ADDWFC FSR0H, F
0117  3F00     MOVIW 0[FSR0]
0118  00A8     MOVWF f1
0119  3F01     MOVIW 1[FSR0]
011A  00A9     MOVWF counter
011B  3F02     MOVIW 2[FSR0]
011C  00AA     MOVWF exp
011D  083F     MOVF 0x3F, W
011E  00AB     MOVWF f2
011F  0840     MOVF 0x40, W
0120  00AC     MOVWF 0x2C
0121  0841     MOVF 0x41, W
0122  00AD     MOVWF 0x2D
0123  3197     MOVLP 0x17
0124  2765     CALL 0x765
0125  0828     MOVF f1, W
0126  00B8     MOVWF 0x38
0127  0829     MOVF counter, W
0128  00B9     MOVWF 0x39
0129  082A     MOVF exp, W
012A  00BA     MOVWF 0x3A
012B  0008     RETURN
440:           		else if(scl > 10)
012C  0842     MOVF scl, W
012D  3A80     XORLW 0x80
012E  3E75     ADDLW 0x75
012F  1C03     BTFSS STATUS, 0x0
0130  298B     GOTO 0x18B
441:           			return _npowers_[(uns_expon)(scl/10+9)] * _npowers_[(uns_expon)(scl%10)];
0131  0842     MOVF scl, W
0132  00F2     MOVWF dividend
0133  01F3     CLRF exp
0134  1BF2     BTFSC dividend, 0x7
0135  03F3     DECF exp, F
0136  300A     MOVLW 0xA
0137  00F0     MOVWF __pcstackCOMMON
0138  3000     MOVLW 0x0
0139  00F1     MOVWF c
013A  3194     MOVLP 0x14
013B  249E     CALL 0x49E
013C  3180     MOVLP 0x0
013D  0870     MOVF __pcstackCOMMON, W
013E  00BB     MOVWF 0x3B
013F  01BC     CLRF 0x3C
0140  083B     MOVF 0x3B, W
0141  00A4     MOVWF multiplier
0142  083C     MOVF 0x3C, W
0143  00A5     MOVWF exp1
0144  3003     MOVLW 0x3
0145  00A6     MOVWF multiplicand
0146  3000     MOVLW 0x0
0147  00A7     MOVWF f1
0148  3193     MOVLP 0x13
0149  2304     CALL 0x304
014A  3180     MOVLP 0x0
014B  0825     MOVF exp1, W
014C  0085     MOVWF FSR0H
014D  0824     MOVF multiplier, W
014E  0084     MOVWF FSR0
014F  304F     MOVLW 0x4F
0150  0784     ADDWF FSR0, F
0151  3098     MOVLW 0x98
0152  3D85     ADDWFC FSR0H, F
0153  3F00     MOVIW 0[FSR0]
0154  00A8     MOVWF f1
0155  3F01     MOVIW 1[FSR0]
0156  00A9     MOVWF counter
0157  3F02     MOVIW 2[FSR0]
0158  00AA     MOVWF exp
0159  0842     MOVF scl, W
015A  00F9     MOVWF counter
015B  01FA     CLRF quotient
015C  1BF9     BTFSC counter, 0x7
015D  03FA     DECF quotient, F
015E  300A     MOVLW 0xA
015F  00F7     MOVWF divisor
0160  3000     MOVLW 0x0
0161  00F8     MOVWF c
0162  3195     MOVLP 0x15
0163  25D5     CALL 0x5D5
0164  3180     MOVLP 0x0
0165  0877     MOVF divisor, W
0166  3E09     ADDLW 0x9
0167  00BD     MOVWF 0x3D
0168  01BE     CLRF 0x3E
0169  083D     MOVF 0x3D, W
016A  00A4     MOVWF multiplier
016B  083E     MOVF 0x3E, W
016C  00A5     MOVWF exp1
016D  3003     MOVLW 0x3
016E  00A6     MOVWF multiplicand
016F  3000     MOVLW 0x0
0170  00A7     MOVWF f1
0171  3193     MOVLP 0x13
0172  2304     CALL 0x304
0173  3180     MOVLP 0x0
0174  0825     MOVF exp1, W
0175  0085     MOVWF FSR0H
0176  0824     MOVF multiplier, W
0177  0084     MOVWF FSR0
0178  304F     MOVLW 0x4F
0179  0784     ADDWF FSR0, F
017A  3098     MOVLW 0x98
017B  3D85     ADDWFC FSR0H, F
017C  3F00     MOVIW 0[FSR0]
017D  00AB     MOVWF f2
017E  3F01     MOVIW 1[FSR0]
017F  00AC     MOVWF 0x2C
0180  3F02     MOVIW 2[FSR0]
0181  00AD     MOVWF 0x2D
0182  3197     MOVLP 0x17
0183  2765     CALL 0x765
0184  0828     MOVF f1, W
0185  00B8     MOVWF 0x38
0186  0829     MOVF counter, W
0187  00B9     MOVWF 0x39
0188  082A     MOVF exp, W
0189  00BA     MOVWF 0x3A
018A  0008     RETURN
442:           		return _npowers_[(uns_expon)scl];
018B  0842     MOVF scl, W
018C  00BB     MOVWF 0x3B
018D  01BC     CLRF 0x3C
018E  083B     MOVF 0x3B, W
018F  00A4     MOVWF multiplier
0190  083C     MOVF 0x3C, W
0191  00A5     MOVWF exp1
0192  3003     MOVLW 0x3
0193  00A6     MOVWF multiplicand
0194  3000     MOVLW 0x0
0195  00A7     MOVWF f1
0196  3193     MOVLP 0x13
0197  2304     CALL 0x304
0198  0825     MOVF exp1, W
0199  0085     MOVWF FSR0H
019A  0824     MOVF multiplier, W
019B  0084     MOVWF FSR0
019C  304F     MOVLW 0x4F
019D  0784     ADDWF FSR0, F
019E  3098     MOVLW 0x98
019F  3D85     ADDWFC FSR0H, F
01A0  3F00     MOVIW 0[FSR0]
01A1  00B8     MOVWF 0x38
01A2  3F01     MOVIW 1[FSR0]
01A3  00B9     MOVWF 0x39
01A4  3F02     MOVIW 2[FSR0]
01A5  00BA     MOVWF 0x3A
01A6  0008     RETURN
443:           	}
444:           	if(scl>=110)
01A7  0842     MOVF scl, W
01A8  3A80     XORLW 0x80
01A9  3E12     ADDLW 0x12
01AA  1C03     BTFSS STATUS, 0x0
01AB  2A49     GOTO 0x249
445:           		return _powers_[(uns_expon)(scl/100+18)] * _powers_[(uns_expon)((scl%100)/10+9)] * _powers_[(uns_expon)(scl%10)];
01AC  0842     MOVF scl, W
01AD  00F2     MOVWF dividend
01AE  01F3     CLRF exp
01AF  1BF2     BTFSC dividend, 0x7
01B0  03F3     DECF exp, F
01B1  3064     MOVLW 0x64
01B2  00F0     MOVWF __pcstackCOMMON
01B3  3000     MOVLW 0x0
01B4  00F1     MOVWF c
01B5  3194     MOVLP 0x14
01B6  249E     CALL 0x49E
01B7  3180     MOVLP 0x0
01B8  0871     MOVF c, W
01B9  00FA     MOVWF quotient
01BA  0870     MOVF __pcstackCOMMON, W
01BB  00F9     MOVWF counter
01BC  300A     MOVLW 0xA
01BD  00F7     MOVWF divisor
01BE  3000     MOVLW 0x0
01BF  00F8     MOVWF c
01C0  3195     MOVLP 0x15
01C1  25D5     CALL 0x5D5
01C2  3180     MOVLP 0x0
01C3  0877     MOVF divisor, W
01C4  3E09     ADDLW 0x9
01C5  00BB     MOVWF 0x3B
01C6  01BC     CLRF 0x3C
01C7  083B     MOVF 0x3B, W
01C8  00A4     MOVWF multiplier
01C9  083C     MOVF 0x3C, W
01CA  00A5     MOVWF exp1
01CB  3003     MOVLW 0x3
01CC  00A6     MOVWF multiplicand
01CD  3000     MOVLW 0x0
01CE  00A7     MOVWF f1
01CF  3193     MOVLP 0x13
01D0  2304     CALL 0x304
01D1  3180     MOVLP 0x0
01D2  0825     MOVF exp1, W
01D3  0085     MOVWF FSR0H
01D4  0824     MOVF multiplier, W
01D5  0084     MOVWF FSR0
01D6  3028     MOVLW 0x28
01D7  0784     ADDWF FSR0, F
01D8  3098     MOVLW 0x98
01D9  3D85     ADDWFC FSR0H, F
01DA  3F00     MOVIW 0[FSR0]
01DB  00A8     MOVWF f1
01DC  3F01     MOVIW 1[FSR0]
01DD  00A9     MOVWF counter
01DE  3F02     MOVIW 2[FSR0]
01DF  00AA     MOVWF exp
01E0  0842     MOVF scl, W
01E1  00F9     MOVWF counter
01E2  01FA     CLRF quotient
01E3  1BF9     BTFSC counter, 0x7
01E4  03FA     DECF quotient, F
01E5  3064     MOVLW 0x64
01E6  00F7     MOVWF divisor
01E7  3000     MOVLW 0x0
01E8  00F8     MOVWF c
01E9  3195     MOVLP 0x15
01EA  25D5     CALL 0x5D5
01EB  3180     MOVLP 0x0
01EC  0877     MOVF divisor, W
01ED  3E12     ADDLW 0x12
01EE  00BD     MOVWF 0x3D
01EF  01BE     CLRF 0x3E
01F0  083D     MOVF 0x3D, W
01F1  00A4     MOVWF multiplier
01F2  083E     MOVF 0x3E, W
01F3  00A5     MOVWF exp1
01F4  3003     MOVLW 0x3
01F5  00A6     MOVWF multiplicand
01F6  3000     MOVLW 0x0
01F7  00A7     MOVWF f1
01F8  3193     MOVLP 0x13
01F9  2304     CALL 0x304
01FA  3180     MOVLP 0x0
01FB  0825     MOVF exp1, W
01FC  0085     MOVWF FSR0H
01FD  0824     MOVF multiplier, W
01FE  0084     MOVWF FSR0
01FF  3028     MOVLW 0x28
0200  0784     ADDWF FSR0, F
0201  3098     MOVLW 0x98
0202  3D85     ADDWFC FSR0H, F
0203  3F00     MOVIW 0[FSR0]
0204  00AB     MOVWF f2
0205  3F01     MOVIW 1[FSR0]
0206  00AC     MOVWF 0x2C
0207  3F02     MOVIW 2[FSR0]
0208  00AD     MOVWF 0x2D
0209  3197     MOVLP 0x17
020A  2765     CALL 0x765
020B  3180     MOVLP 0x0
020C  0828     MOVF f1, W
020D  00BF     MOVWF 0x3F
020E  0829     MOVF counter, W
020F  00C0     MOVWF 0x40
0210  082A     MOVF exp, W
0211  00C1     MOVWF 0x41
0212  0842     MOVF scl, W
0213  00F2     MOVWF dividend
0214  01F3     CLRF exp
0215  1BF2     BTFSC dividend, 0x7
0216  03F3     DECF exp, F
0217  300A     MOVLW 0xA
0218  00F0     MOVWF __pcstackCOMMON
0219  3000     MOVLW 0x0
021A  00F1     MOVWF c
021B  3194     MOVLP 0x14
021C  249E     CALL 0x49E
021D  3180     MOVLP 0x0
021E  0870     MOVF __pcstackCOMMON, W
021F  00BB     MOVWF 0x3B
0220  01BC     CLRF 0x3C
0221  083B     MOVF 0x3B, W
0222  00A4     MOVWF multiplier
0223  083C     MOVF 0x3C, W
0224  00A5     MOVWF exp1
0225  3003     MOVLW 0x3
0226  00A6     MOVWF multiplicand
0227  3000     MOVLW 0x0
0228  00A7     MOVWF f1
0229  3193     MOVLP 0x13
022A  2304     CALL 0x304
022B  3180     MOVLP 0x0
022C  0825     MOVF exp1, W
022D  0085     MOVWF FSR0H
022E  0824     MOVF multiplier, W
022F  0084     MOVWF FSR0
0230  3028     MOVLW 0x28
0231  0784     ADDWF FSR0, F
0232  3098     MOVLW 0x98
0233  3D85     ADDWFC FSR0H, F
0234  3F00     MOVIW 0[FSR0]
0235  00A8     MOVWF f1
0236  3F01     MOVIW 1[FSR0]
0237  00A9     MOVWF counter
0238  3F02     MOVIW 2[FSR0]
0239  00AA     MOVWF exp
023A  083F     MOVF 0x3F, W
023B  00AB     MOVWF f2
023C  0840     MOVF 0x40, W
023D  00AC     MOVWF 0x2C
023E  0841     MOVF 0x41, W
023F  00AD     MOVWF 0x2D
0240  3197     MOVLP 0x17
0241  2765     CALL 0x765
0242  0828     MOVF f1, W
0243  00B8     MOVWF 0x38
0244  0829     MOVF counter, W
0245  00B9     MOVWF 0x39
0246  082A     MOVF exp, W
0247  00BA     MOVWF 0x3A
0248  0008     RETURN
446:           	else if(scl > 10)
0249  0842     MOVF scl, W
024A  3A80     XORLW 0x80
024B  3E75     ADDLW 0x75
024C  1C03     BTFSS STATUS, 0x0
024D  2AA8     GOTO 0x2A8
447:           		return _powers_[(uns_expon)(scl/10+9)] * _powers_[(uns_expon)(scl%10)];
024E  0842     MOVF scl, W
024F  00F2     MOVWF dividend
0250  01F3     CLRF exp
0251  1BF2     BTFSC dividend, 0x7
0252  03F3     DECF exp, F
0253  300A     MOVLW 0xA
0254  00F0     MOVWF __pcstackCOMMON
0255  3000     MOVLW 0x0
0256  00F1     MOVWF c
0257  3194     MOVLP 0x14
0258  249E     CALL 0x49E
0259  3180     MOVLP 0x0
025A  0870     MOVF __pcstackCOMMON, W
025B  00BB     MOVWF 0x3B
025C  01BC     CLRF 0x3C
025D  083B     MOVF 0x3B, W
025E  00A4     MOVWF multiplier
025F  083C     MOVF 0x3C, W
0260  00A5     MOVWF exp1
0261  3003     MOVLW 0x3
0262  00A6     MOVWF multiplicand
0263  3000     MOVLW 0x0
0264  00A7     MOVWF f1
0265  3193     MOVLP 0x13
0266  2304     CALL 0x304
0267  3180     MOVLP 0x0
0268  0825     MOVF exp1, W
0269  0085     MOVWF FSR0H
026A  0824     MOVF multiplier, W
026B  0084     MOVWF FSR0
026C  3028     MOVLW 0x28
026D  0784     ADDWF FSR0, F
026E  3098     MOVLW 0x98
026F  3D85     ADDWFC FSR0H, F
0270  3F00     MOVIW 0[FSR0]
0271  00A8     MOVWF f1
0272  3F01     MOVIW 1[FSR0]
0273  00A9     MOVWF counter
0274  3F02     MOVIW 2[FSR0]
0275  00AA     MOVWF exp
0276  0842     MOVF scl, W
0277  00F9     MOVWF counter
0278  01FA     CLRF quotient
0279  1BF9     BTFSC counter, 0x7
027A  03FA     DECF quotient, F
027B  300A     MOVLW 0xA
027C  00F7     MOVWF divisor
027D  3000     MOVLW 0x0
027E  00F8     MOVWF c
027F  3195     MOVLP 0x15
0280  25D5     CALL 0x5D5
0281  3180     MOVLP 0x0
0282  0877     MOVF divisor, W
0283  3E09     ADDLW 0x9
0284  00BD     MOVWF 0x3D
0285  01BE     CLRF 0x3E
0286  083D     MOVF 0x3D, W
0287  00A4     MOVWF multiplier
0288  083E     MOVF 0x3E, W
0289  00A5     MOVWF exp1
028A  3003     MOVLW 0x3
028B  00A6     MOVWF multiplicand
028C  3000     MOVLW 0x0
028D  00A7     MOVWF f1
028E  3193     MOVLP 0x13
028F  2304     CALL 0x304
0290  3180     MOVLP 0x0
0291  0825     MOVF exp1, W
0292  0085     MOVWF FSR0H
0293  0824     MOVF multiplier, W
0294  0084     MOVWF FSR0
0295  3028     MOVLW 0x28
0296  0784     ADDWF FSR0, F
0297  3098     MOVLW 0x98
0298  3D85     ADDWFC FSR0H, F
0299  3F00     MOVIW 0[FSR0]
029A  00AB     MOVWF f2
029B  3F01     MOVIW 1[FSR0]
029C  00AC     MOVWF 0x2C
029D  3F02     MOVIW 2[FSR0]
029E  00AD     MOVWF 0x2D
029F  3197     MOVLP 0x17
02A0  2765     CALL 0x765
02A1  0828     MOVF f1, W
02A2  00B8     MOVWF 0x38
02A3  0829     MOVF counter, W
02A4  00B9     MOVWF 0x39
02A5  082A     MOVF exp, W
02A6  00BA     MOVWF 0x3A
02A7  0008     RETURN
448:           	return _powers_[(uns_expon)scl];
02A8  0842     MOVF scl, W
02A9  00BB     MOVWF 0x3B
02AA  01BC     CLRF 0x3C
02AB  083B     MOVF 0x3B, W
02AC  00A4     MOVWF multiplier
02AD  083C     MOVF 0x3C, W
02AE  00A5     MOVWF exp1
02AF  3003     MOVLW 0x3
02B0  00A6     MOVWF multiplicand
02B1  3000     MOVLW 0x0
02B2  00A7     MOVWF f1
02B3  3193     MOVLP 0x13
02B4  2304     CALL 0x304
02B5  0825     MOVF exp1, W
02B6  0085     MOVWF FSR0H
02B7  0824     MOVF multiplier, W
02B8  0084     MOVWF FSR0
02B9  3028     MOVLW 0x28
02BA  0784     ADDWF FSR0, F
02BB  3098     MOVLW 0x98
02BC  3D85     ADDWFC FSR0H, F
02BD  3F00     MOVIW 0[FSR0]
02BE  00B8     MOVWF 0x38
02BF  3F01     MOVIW 1[FSR0]
02C0  00B9     MOVWF 0x39
02C1  3F02     MOVIW 2[FSR0]
02C2  00BA     MOVWF 0x3A
449:           }
02C3  0008     RETURN
450:           
451:           
452:           #endif	/* __FLOAT */
453:           
454:           
455:           
456:           #ifdef	_HOSTED
457:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
458:           int
459:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
460:           {
461:           	char		cbuf[2];
462:           #else	/* _HOSTED */
463:           int
464:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
465:           #define	pputc(c)	do { if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT); } while(0)
466:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
02C4  0021     MOVLB 0x1
467:           {
468:           #endif
469:           
470:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
471:           #define	pputc(c)	(putch(c) INCR_CNT)
472:           printf(const char * f, ...)
473:           {
474:           	va_list	ap;
475:           #define	NEED_START
476:           #endif
477:           
478:           #if	!defined(PRINTF) && defined(VSPRINTF)
479:           
480:           #ifdef	SPRINTF
481:           sprintf(char * sp, const char * f, ...)
482:           {
483:           	va_list	ap;
484:           
485:           	va_start(ap, f);
486:           	vsprintf(sp, f, ap);
487:           	va_end(ap);
488:           }
489:           int
490:           #endif	// SPRINTF
491:           
492:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
493:           vsprintf(char * sp, register const  char * f, register va_list ap)
494:           {
495:           #define NEED_START
496:           #endif	// VSPRINTF
497:           
498:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
499:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
500:           sprintf(char * sp, const  char * f, ...)
501:           {
502:           	va_list	ap;
503:           #define	NEED_START
504:           #endif
505:           #endif	// HOSTED
506:           
507:           	char		c;
508:           #if	defined(WIDTH) || defined(__FLOAT)
509:           	int		width;
510:           #endif
511:           #ifdef	__LONG
512:           	int		prec;
513:           #define uns_prec	unsigned int
514:           #define prec_t		int
515:           #else
516:           	signed char	prec;
517:           #define uns_prec	unsigned char
518:           #define prec_t		signed char
519:           #endif
520:           	FLAG_SIZE	flag;
521:           #ifdef	RETVALUE
522:           	int		ccnt = 0;
523:           #else
524:           #define	ccnt	0
525:           #endif
526:           #ifdef	__FLOAT
527:           	char	d;
528:           	double	fval; 
529:           	int		eexp;
530:           #if DOUBLE
531:           	double		ival;
532:           #endif
533:           #endif
534:           #if ! DOUBLE || __FLOAT
535:           	union {
536:           		unsigned long vd;
537:           		double integ;
538:           	} tmpval;
539:           #endif
540:           	unsigned value	val;
541:           	unsigned	len;
542:           	CONST char *	cp;
543:           	
544:           #ifdef	NEED_START
545:           	va_start(ap, f);
546:           #endif
547:           
548:           	while((c = *f++)) {
02C6  0020     MOVLB 0x0
549:           #ifdef	ANYFORMAT
550:           		if(c != '%')
02DA  3025     MOVLW 0x25
551:           #endif	//ANYFORMAT
552:           		{
553:           			pputc(c);
02DE  0A3A     INCF 0x3A, W
554:           			continue;
555:           		}
556:           #ifdef	ANYFORMAT
557:           #ifdef	WIDTH
558:           		width = 0;
030D  01B7     CLRF sign
559:           #endif
560:           		flag = 0;
030F  01A8     CLRF f1
561:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
562:           		for(;;) {
563:           			switch(*f) {
0319  0020     MOVLB 0x0
564:           #ifdef	LEFT
565:           			case '-':
566:           				flag |= LEFT;
567:           				f++;
568:           				continue;
569:           #endif
570:           
571:           #ifdef	SPCSIGN
572:           			case ' ':
573:           				flag |= SPCSIGN;
574:           				f++;
575:           				continue;
576:           #endif
577:           
578:           #ifdef	MANSIGN
579:           			case '+':
580:           				flag |= MANSIGN;
581:           				f++;
582:           				continue;
583:           #endif
584:           #ifdef	ALTERN
585:           			case '#':
586:           				flag |= ALTERN;
587:           				f++;
588:           				continue;
589:           #endif
590:           #ifdef	FILL
591:           			case '0':
592:           				flag |= FILL;
0312  0021     MOVLB 0x1
593:           				f++;
0314  3001     MOVLW 0x1
594:           				continue;
595:           #endif
596:           			}
597:           			break;
598:           		}
599:           #endif
600:           #if	defined(MANSIGN) && defined(SPCSIGN)
601:           		if(flag & MANSIGN)
602:           			flag &= ~SPCSIGN;
603:           #endif
604:           #if	defined(LEFT) && defined(FILL)
605:           		if(flag & LEFT)
606:           			flag &= ~FILL;
607:           #endif
608:           #ifdef	WIDTH
609:           		if(isdigit((unsigned)*f)) {
0323  085C     MOVF 0xDC, W
610:           			width = 0;
032D  0021     MOVLB 0x1
611:           			do {
612:           				width *= 10;
0330  300A     MOVLW 0xA
613:           			   	width += *f++ - '0';
0347  0020     MOVLB 0x0
614:           			} while(isdigit((unsigned)*f));
035F  085C     MOVF f, W
615:           #ifdef	STAR
616:           		} else if(*f == '*') {
617:           			width = va_arg(ap, int);
618:           			f++;
619:           #endif
620:           		}
621:           #endif
622:           #ifdef	PRECISION
623:           		if(*f == '.') {
624:           			flag |= PRECISION;
625:           			f++;
626:           #ifdef	STAR
627:           			if(*f == '*') {
628:           				prec = va_arg(ap, int);
629:           				if (prec < 0) {
630:           					prec = 0;
631:           					flag &= ~PRECISION;
632:           #ifdef DEFPREC
633:           					flag |= DEFPREC;
634:           #endif
635:           				}
636:           				f++;
637:           			} else
638:           #endif
639:           			{
640:           				prec = 0;
641:           				while(isdigit((unsigned)*f))
642:           					prec = prec*10 + *f++ - '0';
643:           			}
644:           		} else {
645:           			prec = 0;
646:           #ifdef	DEFPREC
647:           			flag |= DEFPREC;
648:           #endif	// DEFPREC
649:           		}
650:           #endif	// PRECISION
651:           #if	defined(__LONG) && defined(LONG)
652:           loop:
653:           #endif
654:           		switch(c = *f++) {
0409  085D     MOVF 0x5D, W
655:           
656:           		case 0:
657:           			goto alldone;
658:           
659:           #ifdef	LONG
660:           		case 'l':
661:           #ifdef	__LONG
662:           			flag |= LONG;
663:           			goto loop;
664:           #else
665:           			cp = "(non-long printf)";
666:           			goto strings;
667:           #endif
668:           #endif
669:           
670:           #ifdef	FLOATFORMAT
671:           #ifndef	__FLOAT
672:           		case 'E':
673:           		case 'f':
674:           		case 'e':
675:           		case 'G':
676:           		case 'g':
677:           			cp = "(non-float printf)";
678:           			goto strings;
679:           #else
680:           #ifdef	FFMT
681:           		case 'f':
682:           			flag |= FFMT;
036A  1529     BSF counter, 0x2
683:           			break;
036B  2C24     GOTO 0x424
684:           #endif
685:           
686:           #ifdef	EFMT
687:           #ifdef	UPCASE
688:           		case 'E':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'e':
692:           			flag |= EFMT;
693:           			break;
694:           #endif
695:           
696:           #ifdef	GFMT
697:           #ifdef	UPCASE
698:           		case 'G':
699:           			flag |= UPCASE;
700:           #endif
701:           		case 'g':
702:           			flag |= GFMT;
703:           			break;
704:           #endif	// GFMT
705:           #endif
706:           #endif	// FLOATFORMAT
707:           #ifdef	EIGHT
708:           		case 'o':
709:           #ifdef	MULTRAD
710:           			flag |= EIGHT;
711:           #endif
712:           			break;
713:           #endif
714:           
715:           #ifdef	TEN
716:           		case 'd':
717:           		case 'i':
718:           			break;
719:           #endif
720:           
721:           #ifdef	POINTER
722:           		case 'p':
723:           #if	i8086 && LARGE_DATA
724:           			flag |= LONG;
725:           #elif	_PIC18
726:           			flag |= POINTER;
727:           #endif
728:           #endif	// POINTER
729:           #ifdef	SIXTEEN
730:           #ifdef	HEXUPCASE
731:           		case 'X':
732:           #ifdef	UPCASE
733:           			flag |= UPCASE;
734:           #endif
735:           #endif
736:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
737:           		case 'x':
738:           #endif
739:           #ifdef	MULTRAD
740:           			flag |= SIXTEEN;
741:           #endif
742:           			break;
743:           #endif	// SIXTEEN
744:           
745:           #if	defined(STRING) || defined(PERCPERC)
746:           #ifdef	STRING
747:           		case 's':
748:           #if	i8086 && SMALL_DATA
749:           			if(flag & LONG)
750:           				cp = va_arg(ap, __far char *);
751:           			else
752:           #endif
753:           				cp = va_arg(ap, const char *);
754:           #endif	// STRING
755:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
756:           strings:
757:           #endif
758:           #ifdef	STRING
759:           			if(!cp)
760:           				cp = "(null)";
761:           #endif
762:           #if	defined(WIDTH) || defined(PRECISION)
763:           #if	defined(STRING)
764:           			len = 0;
765:           			while(cp[len])
766:           				len++;
767:           #endif
768:           #ifdef	PERCPERC
769:           dostring:
770:           #endif
771:           #ifdef	PRECISION
772:           			if(prec && prec < len)
773:           				len = prec;
774:           #endif	// PRECISION
775:           #ifdef	WIDTH
776:           			if(width > len)
036C  0838     MOVF 0x38, W
777:           				width -= len;
0374  0824     MOVF multiplier, W
778:           			else
779:           				width = 0;
0379  01B7     CLRF sign
780:           #ifdef	LEFT
781:           			if(!(flag & LEFT))
782:           #endif	// LEFT
783:           				while(width--)
037B  30FF     MOVLW 0xFF
03B2  2B7B     GOTO 0x37B
784:           					pputc(' ');
0385  0A3A     INCF 0x3A, W
785:           #endif	// WIDTH
786:           			while(len--)
03F2  3001     MOVLW 0x1
787:           				pputc(*cp++);
03B3  0A3A     INCF 0x3A, W
788:           #ifdef	LEFT
789:           			if(flag & LEFT)
790:           				while(width--)
791:           					pputc(' ');
792:           #endif	// LEFT
793:           			continue;
794:           #else	// WIDTH || PRECISION
795:           #if	defined(STRING)
796:           			while(*cp)
797:           				pputc(*cp++);
798:           			continue;
799:           #endif
800:           #endif	// WIDTH || PRECISION
801:           #endif	// defined(STRING) || defined(PERCPERC)
802:           #ifdef	CHAR
803:           		case 'c':
804:           #if	_HOSTED
805:           			val = va_arg(ap, int);
806:           			c = val >> 8;
807:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
808:           				cbuf[0] = c;
809:           				cbuf[1] = val;
810:           				len = 2;
811:           			} else {
812:           				cbuf[0] = val;
813:           				len = 1;
814:           			}
815:           			cp = cbuf;
816:           			goto dostring;
817:           #else
818:           			c = va_arg(ap, int);
819:           #endif	// _HOSTED
820:           #endif	// CHAR
821:           		default:
822:           #ifdef	PERCPERC
823:           #if	defined(WIDTH) || defined(PRECISION)
824:           			cp = (char *)&c;
03FE  30B9     MOVLW 0xB9
825:           			len = 1;
0404  3001     MOVLW 0x1
826:           			goto dostring;
0408  2B6C     GOTO 0x36C
827:           #else
828:           			pputc(c);
829:           			continue;
830:           #endif
831:           #else	// PERCPERC
832:           			continue;
833:           #endif
834:           
835:           #ifdef	UNSIGN
836:           		case 'u':
837:           			flag |= UNSIGN;
838:           			break;
839:           #endif
840:           
841:           		}
842:           #endif	// ANYFORMAT
843:           #ifdef	__FLOAT
844:           		if(flag & (FLOATFORMAT)) {
0424  3000     MOVLW 0x0
845:           #ifdef	DEFPREC
846:           			if(flag & DEFPREC)
847:           #endif
848:           				prec = 6;
0432  3006     MOVLW 0x6
849:           			fval = va_arg(ap, double);	// source the floating point value
0437  0020     MOVLB 0x0
850:           			if(fval < 0.0) {
0447  0834     MOVF 0x34, W
851:           				fval = -fval;		// get the absolute value
0458  0834     MOVF 0x34, W
852:           				flag |= NEGSIGN;
0467  3003     MOVLW 0x3
853:           			}
854:           			eexp = 0;		/* If the number is zero, the exponent is zero. */
046B  01AE     CLRF cntr
855:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
046D  0836     MOVF cntr, W
856:           				frexp(fval, &eexp);		/* get binary exponent */
0472  30B4     MOVLW 0xB4
857:           				eexp--;				/* adjust 0.5 -> 1.0 */
0494  30FF     MOVLW 0xFF
858:           				eexp *= 3;
0498  3003     MOVLW 0x3
859:           				eexp /= 10;			/* estimate decimal exponent */
04AF  300A     MOVLW 0xA
860:           				if(eexp < 0)
04BF  1FAF     BTFSS f3, 0x7
861:           					eexp--;
04C1  30FF     MOVLW 0xFF
862:           				// the following line can cause "recursive call" errors because scale calls
863:           				// ftmul, and is used when evaluating an argument to ftmul
864:           				//integ = fval * scale(-eexp);
865:           				tmpval.integ = scale(-eexp);		// replaced with this
04C5  032E     DECF cntr, W
866:           				tmpval.integ *= fval;
04D5  0834     MOVF 0x34, W
867:           				if(tmpval.integ < 1.0)
04FA  0830     MOVF 0x30, W
868:           					eexp--;
050B  30FF     MOVLW 0xFF
869:           				else if(tmpval.integ >= 10.0)
050F  0830     MOVF 0x30, W
870:           					eexp++;
0520  3001     MOVLW 0x1
871:           			}
872:           #if	defined(EFMT) || defined(GFMT)
873:           			if(eexp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
874:           				c = 1;
875:           			else
876:           				c = eexp;
877:           			if(
878:           #ifdef	EFMT
879:           					flag & EFMT
880:           #ifdef	GFMT
881:           					||
882:           #endif
883:           #endif
884:           #ifdef	GFMT
885:           					(flag & GFMT && (eexp < -4 || eexp >= (int)prec))
886:           #endif
887:           				) {	/* use e format */
888:           #ifdef	GFMT
889:           				if(prec && flag & GFMT)
890:           					prec--;		/* g format precision includes integer digit */
891:           #endif
892:           				if((unsigned)prec > NDDIG - 2)
893:           					c = NDDIG - 2;
894:           				else
895:           					c = prec;
896:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
897:           					fval /= scale(eexp-c);
898:           #if	DOUBLE
899:           					ival = _dto64i(fval);
900:           					if(fval - _64itod(ival) >= 0.5) {
901:           						fval += 0.5;
902:           						ival = _dto64i(fval);
903:           					}
904:           					if(ival >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						eexp++;
907:           					} else if(ival < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						eexp--;
910:           					}
911:           #else	
912:           					if(fval - (double)(unsigned long)fval >= 0.5)
913:           						fval += 0.5;
914:           					if((unsigned long)fval >= fdpowers[c+1]) {
915:           						fval *= 1e-1;
916:           						eexp++;
917:           					} else if((unsigned long)fval < fdpowers[c]) {
918:           						fval *= 10.0;
919:           						eexp--;
920:           					}
921:           #endif
922:           				}
923:           #if defined(GFMT) && defined(ALTERN)
924:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
925:           					if(prec > (int)(NDDIG))
926:           						prec = NDDIG;
927:           #if	DOUBLE
928:           					ival = _dto64i(fval);
929:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
930:           						prec--;
931:           						ival = _div64(ival, fdpowers[1]);
932:           					}
933:           #else
934:           					val = (unsigned long)fval;
935:           					while(val && val % 10 == 0) {
936:           						prec--;
937:           						val /= 10;
938:           					}
939:           #endif
940:           					if(prec < c) {
941:           						fval /= scale(c-prec);
942:           						c = prec;
943:           					}
944:           
945:           				}
946:           #endif
947:           #ifdef	WIDTH
948:           				width -=  prec + 5;
949:           #ifdef	ALTERN
950:           				if(prec || flag & ALTERN)
951:           					width--;
952:           #endif
953:           				if(flag & NEGSIGN)
954:           					width--;
955:           #if	DBL_MAX_10_EXP >= 100
956:           #if	DBL_MAX_10_EXP >= 1000
957:           				if(eexp >= 1000 || eexp <= -1000)	/* 4 digit exponent */
958:           					width--;
959:           #endif
960:           				if(eexp >= 100 || eexp <= -100)	/* 3 digit exponent */
961:           					width--;
962:           #endif
963:           #endif	// WIDTH
964:           #ifdef	FILL
965:           				if(flag & FILL) {
966:           #if defined(MANSIGN) && defined(SPCSIGN)
967:           					if(flag & MANSIGN)
968:           						pputc(flag & SPCSIGN ? '-' : '+');
969:           					else if(flag & SPCSIGN)
970:           						pputc(' ');
971:           #endif
972:           					while(width > 0) {
973:           						pputc('0');
974:           						width--;
975:           					}
976:           				} else
977:           #endif	// FILL
978:           				{
979:           #ifdef	WIDTH
980:           #ifdef	LEFT
981:           					if(!(flag & LEFT))
982:           #endif
983:           						while(width > 0) {
984:           							pputc(' ');
985:           							width--;
986:           						}
987:           #endif	// WIDTH
988:           #ifdef	MANSIGN
989:           					if(flag & MANSIGN)
990:           						putsign();
991:           #else
992:           					if(flag & NEGSIGN)
993:           						pputc('-');
994:           #endif	// MANSIGN
995:           #ifdef	SPCSIGN
996:           					else if(flag & SPCSIGN)
997:           						pputc(' ');
998:           #endif	// SPCSIGN
999:           				}
1000:          #if	DOUBLE
1001:          				ival = _dto64i(fval);
1002:          				pputc(_div64ir(ival, fdpowers[c]) + '0');
1003:          #else
1004:          				val = (unsigned long)fval;
1005:          				pputc(val/dpowers[c] + '0');
1006:          				val %= dpowers[c];
1007:          #endif
1008:          #ifdef	ALTERN
1009:          				if(prec || flag & ALTERN)
1010:          #else
1011:          				if(prec)
1012:          #endif
1013:          				{
1014:          					pputc('.');
1015:          					prec -= c;
1016:          					while(c--) {
1017:          #if	DOUBLE
1018:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1019:          #else
1020:          #ifdef	GFMT
1021:          						if(flag & GFMT && val == 0) {
1022:          							prec = c = 0;
1023:          							break;
1024:          						}
1025:          #endif
1026:          						pputc('0' + (val/dpowers[c]));
1027:          						val %= dpowers[c];
1028:          #endif
1029:          					}
1030:          					while(prec) {
1031:          						pputc('0');
1032:          						prec--;
1033:          					}
1034:          				}
1035:          #ifdef	UPCASE
1036:          				if(flag & UPCASE)
1037:          					pputc('E');
1038:          				else
1039:          #endif
1040:          					pputc('e');
1041:          				if(eexp < 0) {
1042:          					eexp = -eexp;
1043:          					pputc('-');
1044:          				} else
1045:          					pputc('+');
1046:          #if	DBL_MAX_10_EXP >= 100
1047:          #if	DBL_MAX_10_EXP >= 1000
1048:          				if(eexp >= 1000) {
1049:          					pputc(eexp / 1000 + '0');
1050:          					eexp %= 1000;
1051:          				}
1052:          #endif
1053:          				if(eexp >= 100) {
1054:          					pputc(eexp / 100 + '0');
1055:          					eexp %= 100;
1056:          				}
1057:          #endif
1058:          				pputc(eexp / 10 + '0');
1059:          				pputc(eexp % 10 + '0');
1060:          #ifdef	LEFT
1061:          				if((flag & LEFT) && width > 0)
1062:          					do
1063:          						pputc(' ');
1064:          					while(--width);
1065:          #endif	// LEFT
1066:          					continue;
1067:          				}
1068:          #endif	// EFMT || GFMT
1069:          				/* here for f format */
1070:          #if	DOUBLE
1071:          #ifdef	GFMT
1072:          				if(flag & GFMT) {
1073:          					if(eexp < 0)	// fractional part only
1074:          						prec -= eexp-1;
1075:          					ival = _dto64i(fval);
1076:          					for(c = 1 ; c != NDDIG ; c++)
1077:          						if(ival < fdpowers[c])
1078:          							break;
1079:          					if(prec > NDDIG)
1080:          						prec = NDDIG;
1081:          					prec -= c;
1082:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1083:          					// see how many zeros are at the end of the fractional part
1084:          					while(prec && _mod64i10(ival) == 0) {
1085:          						prec--;
1086:          						ival = _div64(ival, fdpowers[1]);
1087:          					}
1088:          				}
1089:          #endif	// GFMT
1090:          				if(prec <= (int)NDDIG)
1091:          					fval += fround(prec);
1092:          				if(eexp > (int)(NDDIG)-2) {
1093:          					eexp -= NDDIG-2;
1094:          					ival = _divto64i(fval, scale(eexp));
1095:          					fval = 0.0;
1096:          				} else {
1097:          					ival = _dto64i(fval);
1098:          					fval -= _64itod(ival);
1099:          					eexp = 0;
1100:          				}
1101:          				for(c = 1 ; c != NDDIG ; c++)
1102:          					if(ival < fdpowers[c])
1103:          						break;
1104:          #else	// DOUBLE
1105:          #ifdef	GFMT
1106:          				if(flag & GFMT) {
1107:          					if(eexp < 0)	// fractional part only
1108:          						prec -= (eexp+1);
1109:          					// count number of digits in the integral part (this is for %g)
1110:          					val = (unsigned long)fval;
1111:          					for(c = 0 ; c != NDDIG ; c++)
1112:          						if(val < fdpowers[c])
1113:          							break;
1114:          					prec -= c;		// reduce precision by this
1115:          					if(prec <= NDIG)
1116:          						fval += fround(prec);
1117:          					// get fractional part and count trailing zeros - reduce
1118:          					// prec as required
1119:          					{
1120:          						double	temp;
1121:          						temp = scale(prec);
1122:          						temp *= fval - (double)val;
1123:          						val = (unsigned long)temp;
1124:          					}
1125:          					while(prec && val % 10 == 0) {
1126:          						val /= 10;
1127:          						prec--;
1128:          					}
1129:          				} else
1130:          #endif	//GFMT
1131:          					if(prec <= NDIG)
0524  0827     MOVF f1, W
1132:          						fval += fround((uns_prec)prec);
0531  0021     MOVLB 0x1
1133:          
1134:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1135:          				if((eexp > 9)||(fval != 0 && (unsigned long)fval == 0 && eexp > 1)) {
0556  0021     MOVLB 0x1
1136:          					// fval is > 4.2e9
1137:          					// new eexp must be such that div_to_l() is < 4.2e9
1138:          					// OLD CODE:	if(fval / scale(eexp) < 4.294967296){
1139:          					if(tmpval.integ < 4.294967296){
058C  0021     MOVLB 0x1
1140:          						eexp -= NDDIG-1;
059E  30F7     MOVLW 0xF7
1141:          					}else{
1142:          						eexp -= NDDIG-2;
05A0  30F8     MOVLW 0xF8
1143:          					}
1144:          					tmpval.integ = scale(eexp);
05A4  082E     MOVF eexp, W
1145:          					val = div_to_l_(fval, tmpval.integ);
05B3  0834     MOVF fval, W
1146:           					//val = _div_to_l_(integ, fval);
1147:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1148:          					fval = 0.0;	// There will be no fractional component
05CB  3000     MOVLW 0x0
1149:          				} else {
05D1  2E1E     GOTO 0x61E
1150:          					val = (unsigned long)fval;
05D2  0021     MOVLB 0x1
1151:          					fval -= (double)val;
05F0  082D     MOVF 0xAD, W
1152:          					eexp = 0;
061C  01AE     CLRF eexp
1153:          				}
1154:          				// count digits in integral part
1155:          				for(c = 1 ; c != NDDIG ; c++)
061E  01B9     CLRF c
0651  3001     MOVLW 0x1
1156:          					if(val < fdpowers[c])
0624  0839     MOVF c, W
1157:          						break;
1158:          #endif	// DOUBLE
1159:          #ifdef	WIDTH
1160:          				// at this point, c contains the number of whole-number digits to print
1161:          				width -= prec + c + eexp;
065B  0839     MOVF c, W
1162:          				if(
1163:          #ifdef	ALTERN
1164:          						flag & ALTERN ||
1165:          #endif
1166:          						prec)
0676  0826     MOVF prec, W
1167:          					width--;		// allow for decimal point
067A  30FF     MOVLW 0xFF
1168:          				if(flag & NEGSIGN)
067E  0828     MOVF flag, W
1169:          					width--;
0682  30FF     MOVLW 0xFF
1170:          #endif	// WIDTH
1171:          #ifdef	FILL
1172:          				if(flag & FILL) {
0686  1D28     BTFSS flag, 0x2
1173:          #ifdef	MANSIGN
1174:          					if(flag & MANSIGN)
1175:          #else
1176:          					if(flag & NEGSIGN)
0688  0828     MOVF flag, W
1177:          #endif	// MANSIGN
1178:          						putsign();
068C  0A3A     INCF pb, W
1179:          #if defined(MANSIGN) && defined(SPCSIGN)
1180:          					else
1181:          #endif
1182:          #ifdef	SPCSIGN
1183:          					if(flag & SPCSIGN)
1184:          						pputc(' ');
1185:          #endif	// SPCSIGN
1186:          #ifdef	WIDTH
1187:          					while(width > 0) {
06B9  0021     MOVLB 0x1
06FA  2EB9     GOTO 0x6B9
1188:          						pputc('0');
06C7  0021     MOVLB 0x1
1189:          						width--;
06F5  30FF     MOVLW 0xFF
1190:          					}
1191:          #endif	// WIDTH
1192:          				} else
1193:          #endif	// FILL
1194:          				{
1195:          #ifdef	LEFT
1196:          					if(!(flag & LEFT))
1197:          #endif
1198:          #ifdef	WIDTH
1199:          					while(width > 0) {
072E  0838     MOVF 0xB8, W
1200:          						pputc(' ');
06FB  0021     MOVLB 0x1
1201:          						width--;
0729  30FF     MOVLW 0xFF
1202:          					}
1203:          #endif	// WIDTH
1204:          #ifdef	MANSIGN
1205:          				if(flag & MANSIGN)
1206:          #else
1207:          				if(flag & NEGSIGN)
073B  0021     MOVLB 0x1
1208:          #endif	// MANSIGN
1209:          					putsign();
0740  0A3A     INCF pb, W
1210:          #ifdef	SPCSIGN
1211:          				else if(flag & SPCSIGN)
1212:          					pputc(' ');
1213:          #endif	// SPCSIGN
1214:          			}
1215:          			while(c--) {
076D  3001     MOVLW 0x1
0C4C  3187     MOVLP 0x7
1216:          #if	DOUBLE
1217:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1218:          #else
1219:          				{
1220:          					tmpval.vd = val/dpowers[c];
0774  0839     MOVF c, W
1221:          					tmpval.vd %= 10;
079E  3000     MOVLW 0x0
1222:          					pputc('0' + tmpval.vd);
0757  0020     MOVLB 0x0
07C9  0A3A     INCF 0x3A, W
0C4A  0830     MOVF 0x30, W
1223:          				}
1224:          #endif	// DOUBLE
1225:          			}
1226:          			while(eexp > 0) {
0C81  082F     MOVF f3, W
1227:          				pputc('0');
0C4E  0021     MOVLB 0x1
1228:          				eexp--;
0C7C  30FF     MOVLW 0xFF
1229:          			}
1230:          			if(prec > (int)(NDDIG-2))
0C8E  0021     MOVLB 0x1
1231:          				c = NDDIG-2;
0C9C  3008     MOVLW 0x8
1232:          			else
1233:          				c = (char)prec;
0C9E  0021     MOVLB 0x1
1234:          			prec -= (prec_t)c;
0CA5  0839     MOVF c, W
1235:          #ifdef	ALTERN
1236:          			if(c || flag & ALTERN)
1237:          #else
1238:          			if(c)
0CB0  0839     MOVF c, W
1239:          #endif
1240:          				pputc('.');
0CB3  0A3A     INCF pb, W
1241:          #if	DOUBLE
1242:          			ival = _dto64i(fval * scale(c));
1243:          			while(c)
1244:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1245:          #else	// DOUBLE
1246:          			val = (unsigned value)(fval * scale((expon)c));
0CE0  0021     MOVLB 0x1
1247:          			while(c--) {
0D22  3001     MOVLW 0x1
0DE2  2D20     GOTO 0x520
1248:          				tmpval.vd = val/dpowers[c];
0D27  0839     MOVF c, W
1249:          				tmpval.vd %= 10;
0D51  3000     MOVLW 0x0
1250:          				pputc('0' + tmpval.vd);
0D7C  0A3A     INCF pb, W
1251:          				val %= dpowers[c];
0D20  0021     MOVLB 0x1
0DAB  0021     MOVLB 0x1
1252:          			}
1253:          #endif	// DOUBLE
1254:          			while(prec) {
1255:          				pputc('0');
0DE3  0A3A     INCF pb, W
1256:          				prec--;
0E10  30FF     MOVLW 0xFF
1257:          			}
0E15  0826     MOVF prec, W
1258:          #ifdef	LEFT
1259:          			if((flag & LEFT) && width > 0)
1260:          				do
1261:          					pputc(' ');
1262:          				while(--width);
1263:          #endif
1264:          			continue;
1265:          		}
1266:          #endif	/* __FLOAT */
1267:          
1268:          #if	defined(TEN)
1269:          #ifdef	BASEM
1270:          		if((flag & BASEM) == TEN)
1271:          #endif	//BASEM
1272:          		{
1273:          #ifdef	LONG
1274:          			if(flag & LONG)
1275:          				val = va_arg(ap, long);
1276:          			else
1277:          #endif	// LONG
1278:          				val = (value)va_arg(ap, int);
0E1A  085E     MOVF 0xDE, W
1279:          #ifdef	NEGSIGN
1280:          			if((value)val < 0) {
0E32  1FAD     BTFSS 0xAD, 0x7
1281:          				flag |= NEGSIGN;
0E34  3003     MOVLW 0x3
1282:          				val = -val;
0E38  09AA     COMF val, F
1283:          			}
1284:          #endif
1285:          		}
1286:          #ifdef	BASEM
1287:          		else
1288:          #endif
1289:          #endif	// TEN
1290:          
1291:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1292:          		{
1293:          #ifdef	__LONG
1294:          #if	defined(_PIC18) && defined(POINTER)
1295:          			if(flag & POINTER)
1296:          				val = (unsigned long)va_arg(ap, __far char *);
1297:          			else
1298:          #endif
1299:          #ifdef	LONG
1300:          				if(flag & LONG)
1301:          				val = va_arg(ap, unsigned long);
1302:          			else
1303:          #endif	// LONG
1304:          #endif	// __LONG
1305:          				val = va_arg(ap, unsigned);
1306:          		}
1307:          #endif	// EIGHT or SIXTEEN or UNSIGN
1308:          #ifdef	PRECISION
1309:          		if(prec == 0 && val == 0)
1310:          			prec++;
1311:          #endif
1312:          #ifdef	MULTRAD
1313:          		switch((unsigned char)(flag & BASEM)) {
1314:          #endif
1315:          #if	defined(TEN) || defined(UNSIGN)
1316:          #ifdef	MULTRAD
1317:          #ifdef	TEN
1318:          		case TEN:
1319:          #endif
1320:          #ifdef	UNSIGN
1321:          		case UNSIGN:
1322:          #endif
1323:          #endif	// MULTRAD
1324:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
0E43  01B9     CLRF c
0E76  3001     MOVLW 0x1
1325:          				if(val < dpowers[c])
0E49  0839     MOVF c, W
1326:          					break;
1327:          #ifdef	MULTRAD
1328:          			break;
1329:          #endif
1330:          #endif	// TEN || UNSIGN
1331:          #ifdef	SIXTEEN
1332:          #ifdef	MULTRAD
1333:          		case SIXTEEN:
1334:          #endif	// MULTRAD
1335:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1336:          				if(val < hexpowers[c])
1337:          					break;
1338:          #ifdef	MULTRAD
1339:          			break;
1340:          #endif
1341:          #endif
1342:          
1343:          #ifdef	EIGHT
1344:          #ifdef	MULTRAD
1345:          		case EIGHT:
1346:          #endif	// MULTRAD
1347:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1348:          				if(val < octpowers[c])
1349:          					break;
1350:          #ifdef	MULTRAD
1351:          			break;
1352:          #endif
1353:          #endif
1354:          #ifdef	MULTRAD
1355:          		}
1356:          #endif
1357:          #ifdef	PRECISION
1358:          		if(c < prec)
1359:          			c = prec;
1360:          		else if(prec < c)
1361:          			prec = c;
1362:          #endif
1363:          #if	defined(WIDTH) && defined(NEGSIGN)
1364:          		if(width && flag & NEGSIGN)
0E80  0837     MOVF width, W
1365:          			width--;
0E88  30FF     MOVLW 0xFF
1366:          #ifdef	PRECISION
1367:          		if(flag & PRECISION) {
1368:          			if(width > prec)
1369:          				width -= prec;
1370:          			else
1371:          				width = 0;
1372:          		}
1373:          #endif
1374:          #ifdef	ALTERN
1375:          #ifdef	EIGHT
1376:          		if((flag & (
1377:          #ifdef	FILL
1378:          						FILL|
1379:          #endif
1380:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1381:          			if(width)
1382:          				width--;
1383:          		} else
1384:          #endif	// EIGHT
1385:          #if	defined(SIXTEEN)
1386:          #ifdef	BASEM
1387:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1388:          #else
1389:          		if(flag & ALTERN) {
1390:          #endif
1391:          			if(width > 2)
1392:          				width -= 2;
1393:          			else
1394:          				width = 0;
1395:          		}
1396:          #endif	// SIXTEEN
1397:          #endif	// ALTERN
1398:          #endif	// WIDTH
1399:          #ifdef	WIDTH
1400:          		if(width > c)
0E8C  0838     MOVF 0xB8, W
1401:          			width -= c;
0E95  0021     MOVLB 0x1
1402:          		else
1403:          			width = 0;
0EA2  0021     MOVLB 0x1
1404:          #endif
1405:          #ifdef	FILL
1406:          		if(flag & FILL) {
0EA5  1D28     BTFSS flag, 0x2
1407:          #ifdef	MANSIGN
1408:          			if(flag & MANSIGN)
1409:          				putsign();
1410:          #elif defined(NEGSIGN)
1411:          			if(flag & NEGSIGN)
0EA7  0828     MOVF flag, W
1412:          				pputc('-');
0EAB  0A3A     INCF pb, W
1413:          #endif
1414:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1415:          			else
1416:          #endif	// MANSIGN
1417:          #ifdef	SPCSIGN
1418:          			if(flag & SPCSIGN)
1419:          				pputc(' ');
1420:          #endif
1421:          #if defined(ALTERN) && defined(SIXTEEN) && defined(BASEM)
1422:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1423:          				pputc('0');
1424:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1425:          				pputc(flag & UPCASE ? 'X' : 'x');
1426:          #elif defined(HEXUPCASE)
1427:          				pputc('X');
1428:          #else
1429:          				pputc('x');
1430:          #endif	// HEXUPCASE
1431:          			}
1432:          #endif	// ALTERN
1433:          #ifdef	WIDTH
1434:          			if(width)
0ED8  0021     MOVLB 0x1
1435:          				do
1436:          					pputc('0');
0EDD  0A3A     INCF pb, W
1437:          				while(--width);
0F0A  30FF     MOVLW 0xFF
1438:          #endif	// WIDTH
1439:          		} else
1440:          #endif	//FILL
1441:          		{
1442:          #ifdef	WIDTH
1443:          			if(width
1444:          #ifdef	LEFT
1445:          					&& !(flag & LEFT)
1446:          #endif
1447:          					)
0F10  0837     MOVF width, W
1448:          				do
1449:          					pputc(' ');
0F14  0A3A     INCF pb, W
1450:          				while(--width);
0F41  30FF     MOVLW 0xFF
1451:          #endif	// WIDTH
1452:          #ifdef	MANSIGN
1453:          			if(flag & MANSIGN)
1454:          				putsign();
1455:          #else
1456:          #ifdef	NEGSIGN
1457:          			if(flag & NEGSIGN)
0F4A  0828     MOVF flag, W
1458:          				pputc('-');
0F4E  0A3A     INCF pb, W
1459:          #endif
1460:          #endif	// MANSIGN
1461:          #ifdef	SPCSIGN
1462:          			else if(flag & SPCSIGN)
1463:          				pputc(' ');
1464:          #endif
1465:          #ifdef	ALTERN
1466:          #ifdef	EIGHT
1467:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1468:          				pputc('0');
1469:          			else
1470:          #endif	// EIGHT
1471:          #ifdef	SIXTEEN
1472:          #ifdef	BASEM
1473:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1474:          #else
1475:          			if(flag & ALTERN) {
1476:          #endif
1477:          				pputc('0');
1478:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1479:          				pputc(flag & UPCASE ? 'X' : 'x');
1480:          #elif defined(HEXUPCASE)
1481:          				pputc('X');
1482:          #else
1483:          				pputc('x');
1484:          #endif
1485:          			}
1486:          #endif	// SIXTEEN
1487:          #endif	// ALTERN
1488:          		}
1489:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1490:          #ifndef	PRECISION
1491:          		prec = c;
0F7B  0021     MOVLB 0x1
1492:          #endif
1493:          		while(prec--) {
0F87  30FF     MOVLW 0xFF
0FF9  2F87     GOTO 0x787
1494:          #ifdef	MULTRAD
1495:          			switch((unsigned char)(flag & BASEM))
1496:          #endif
1497:          			{
1498:          
1499:          #if	defined(TEN) || defined(UNSIGN)
1500:          #ifdef	MULTRAD
1501:          #ifdef	TEN
1502:          		case TEN:
1503:          #endif
1504:          #ifdef	UNSIGN
1505:          		case UNSIGN:
1506:          #endif
1507:          #endif	// MULTRAD
1508:          				c = (val / dpowers[prec]) % 10 + '0';
0F91  3000     MOVLW 0x0
1509:          #ifdef	MULTRAD
1510:          				break;
1511:          #endif
1512:          #endif	// TEN || UNSIGN
1513:          
1514:          #ifdef	SIXTEEN
1515:          #ifdef	MULTRAD
1516:          			case SIXTEEN:
1517:          #endif
1518:          			{
1519:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1520:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1521:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1522:          #elif	defined(HEXUPCASE)
1523:          				c = "0123456789ABCDEF"[idx];
1524:          #else
1525:          				c = "0123456789abcdef"[idx];
1526:          #endif	//HEXCASE
1527:          			}
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif
1531:          #endif
1532:          
1533:          #ifdef	EIGHT
1534:          #ifdef	MULTRAD
1535:          			case EIGHT:
1536:          #endif	// MULTRAD
1537:          				c = ((val / octpowers[prec]) & 07) + '0';
1538:          #ifdef	MULTRAD
1539:          				break;
1540:          #endif	// MULTRAD
1541:          #endif	// EIGHT
1542:          			}
1543:          			pputc(c);
0FCC  0A3A     INCF pb, W
1544:          		}
1545:          #endif	// 16 or 10 or 8
1546:          #ifdef	LEFT
1547:          		if((flag & LEFT) && width > 0)
1548:          			do
1549:          				pputc(' ');
1550:          			while(--width);
1551:          #endif	// LEFT
1552:          	}
1553:          #ifdef	ANYFORMAT
1554:          alldone:
1555:          #endif	// ANYFORMAT
1556:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1557:          	*sp = 0;
1558:          #endif
1559:          	return ccnt;
0FFA  0020     MOVLB 0x0
1560:          }
0FFD  0008     RETURN
1561:          
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/awmod.c  -------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awmod(signed int divisor, signed int dividend)
6:             #else
7:             __awmod(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	unsigned char	counter, sign;
11:            
12:            	sign = 0;
149E  01F6     CLRF divisor
13:            	if(dividend < 0) {
149F  1FF3     BTFSS exp, 0x7
14A0  2CA8     GOTO 0x4A8
14:            		dividend = -dividend;
14A1  09F2     COMF dividend, F
14A2  09F3     COMF exp, F
14A3  0AF2     INCF dividend, F
14A4  1903     BTFSC STATUS, 0x2
14A5  0AF3     INCF exp, F
15:            		sign = 1;
14A6  01F6     CLRF divisor
14A7  0AF6     INCF divisor, F
16:            	}
17:            	if(divisor < 0)
14A8  1FF1     BTFSS c, 0x7
14A9  2CAF     GOTO 0x4AF
18:            		divisor = -divisor;
14AA  09F0     COMF __pcstackCOMMON, F
14AB  09F1     COMF c, F
14AC  0AF0     INCF __pcstackCOMMON, F
14AD  1903     BTFSC STATUS, 0x2
14AE  0AF1     INCF c, F
19:            	if(divisor != 0) {
14AF  0870     MOVF __pcstackCOMMON, W
14B0  0471     IORWF c, W
14B1  1903     BTFSC STATUS, 0x2
14B2  2CD6     GOTO 0x4D6
20:            		counter = 1;
14B3  01F5     CLRF rem
14B4  0AF5     INCF rem, F
21:            		while(((unsigned int)divisor & 0x8000U) == 0) {
14B5  1BF1     BTFSC c, 0x7
14B6  2CC1     GOTO 0x4C1
14C0  2CB5     GOTO 0x4B5
22:            			divisor <<= 1;
14B7  3001     MOVLW 0x1
14B8  35F0     LSLF __pcstackCOMMON, F
14B9  0DF1     RLF c, F
14BA  0B89     DECFSZ WREG, F
14BB  2CB8     GOTO 0x4B8
23:            			counter++;
14BC  3001     MOVLW 0x1
14BD  00F4     MOVWF sign
14BE  0874     MOVF sign, W
14BF  07F5     ADDWF rem, F
24:            		}
25:            		do {
26:            			if((unsigned int)divisor <= (unsigned int)dividend)
14C1  0871     MOVF c, W
14C2  0273     SUBWF exp, W
14C3  1D03     BTFSS STATUS, 0x2
14C4  2CC7     GOTO 0x4C7
14C5  0870     MOVF __pcstackCOMMON, W
14C6  0272     SUBWF dividend, W
14C7  1C03     BTFSS STATUS, 0x0
14C8  2CCD     GOTO 0x4CD
27:            				dividend -= divisor;
14C9  0870     MOVF __pcstackCOMMON, W
14CA  02F2     SUBWF dividend, F
14CB  0871     MOVF c, W
14CC  3BF3     SUBWFB exp, F
28:            			*(unsigned int *)&divisor >>= 1;
14CD  3001     MOVLW 0x1
14CE  36F1     LSRF c, F
14CF  0CF0     RRF __pcstackCOMMON, F
14D0  0B89     DECFSZ WREG, F
14D1  2CCE     GOTO 0x4CE
29:            		} while(--counter != 0);
14D2  3001     MOVLW 0x1
14D3  02F5     SUBWF rem, F
14D4  1D03     BTFSS STATUS, 0x2
14D5  2CC1     GOTO 0x4C1
30:            	}
31:            	if(sign)
14D6  0876     MOVF divisor, W
14D7  1903     BTFSC STATUS, 0x2
14D8  2CDE     GOTO 0x4DE
32:            		dividend = -dividend;
14D9  09F2     COMF dividend, F
14DA  09F3     COMF exp, F
14DB  0AF2     INCF dividend, F
14DC  1903     BTFSC STATUS, 0x2
14DD  0AF3     INCF exp, F
33:            	return dividend;
14DE  0873     MOVF exp, W
14DF  00F1     MOVWF c
14E0  0872     MOVF dividend, W
14E1  00F0     MOVWF __pcstackCOMMON
34:            }
14E2  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/awdiv.c  -------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
15D5  0020     MOVLB 0x0
15D6  01A1     CLRF sign
14:            	if(divisor < 0) {
15D7  1FF8     BTFSS c, 0x7
15D8  2DE0     GOTO 0x5E0
15:            		divisor = -divisor;
15D9  09F7     COMF divisor, F
15DA  09F8     COMF c, F
15DB  0AF7     INCF divisor, F
15DC  1903     BTFSC STATUS, 0x2
15DD  0AF8     INCF c, F
16:            		sign = 1;
15DE  01A1     CLRF sign
15DF  0AA1     INCF sign, F
17:            	}
18:            	if(dividend < 0) {
15E0  1FFA     BTFSS quotient, 0x7
15E1  2DEB     GOTO 0x5EB
19:            		dividend = -dividend;
15E2  09F9     COMF counter, F
15E3  09FA     COMF quotient, F
15E4  0AF9     INCF counter, F
15E5  1903     BTFSC STATUS, 0x2
15E6  0AFA     INCF quotient, F
20:            		sign ^= 1;
15E7  3001     MOVLW 0x1
15E8  00FB     MOVWF c
15E9  087B     MOVF c, W
15EA  06A1     XORWF sign, F
21:            	}
22:            	quotient = 0;
15EB  01A2     CLRF quotient
15EC  01A3     CLRF 0x23
23:            	if(divisor != 0) {
15ED  0877     MOVF divisor, W
15EE  0478     IORWF c, W
15EF  1903     BTFSC STATUS, 0x2
15F0  2E1A     GOTO 0x61A
24:            		counter = 1;
15F1  01A0     CLRF __pcstackBANK0
15F2  0AA0     INCF __pcstackBANK0, F
25:            		while((divisor & 0x8000U) == 0) {
15F3  1BF8     BTFSC c, 0x7
15F4  2DFF     GOTO 0x5FF
15FE  2DF3     GOTO 0x5F3
26:            			divisor <<= 1;
15F5  3001     MOVLW 0x1
15F6  35F7     LSLF divisor, F
15F7  0DF8     RLF c, F
15F8  0B89     DECFSZ WREG, F
15F9  2DF6     GOTO 0x5F6
27:            			counter++;
15FA  3001     MOVLW 0x1
15FB  00FB     MOVWF c
15FC  087B     MOVF c, W
15FD  07A0     ADDWF __pcstackBANK0, F
28:            		}
29:            		do {
30:            			quotient <<= 1;
15FF  3001     MOVLW 0x1
1600  35A2     LSLF quotient, F
1601  0DA3     RLF 0x23, F
1602  0B89     DECFSZ WREG, F
1603  2E00     GOTO 0x600
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
1604  0878     MOVF c, W
1605  027A     SUBWF quotient, W
1606  1D03     BTFSS STATUS, 0x2
1607  2E0A     GOTO 0x60A
1608  0877     MOVF divisor, W
1609  0279     SUBWF counter, W
160A  1C03     BTFSS STATUS, 0x0
160B  2E11     GOTO 0x611
32:            				dividend -= divisor;
160C  0877     MOVF divisor, W
160D  02F9     SUBWF counter, F
160E  0878     MOVF c, W
160F  3BFA     SUBWFB quotient, F
33:            				quotient |= 1;
1610  1422     BSF quotient, 0x0
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
1611  3001     MOVLW 0x1
1612  36F8     LSRF c, F
1613  0CF7     RRF divisor, F
1614  0B89     DECFSZ WREG, F
1615  2E12     GOTO 0x612
36:            		} while(--counter != 0);
1616  3001     MOVLW 0x1
1617  02A0     SUBWF __pcstackBANK0, F
1618  1D03     BTFSS STATUS, 0x2
1619  2DFF     GOTO 0x5FF
37:            	}
38:            	if(sign)
161A  0821     MOVF sign, W
161B  1903     BTFSC STATUS, 0x2
161C  2E22     GOTO 0x622
39:            		quotient = -quotient;
161D  09A2     COMF quotient, F
161E  09A3     COMF 0x23, F
161F  0AA2     INCF quotient, F
1620  1903     BTFSC STATUS, 0x2
1621  0AA3     INCF 0x23, F
40:            	return quotient;
1622  0823     MOVF 0x23, W
1623  00F8     MOVWF c
1624  0822     MOVF quotient, W
1625  00F7     MOVWF divisor
41:            }
1626  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/altoft.c  ------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.	
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert signed int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(__uint24 *)&f1)
15:            float
16:            __altoft(signed long int c)
17:            {
18:            	float	f1;
19:            	unsigned char	exp, sign;
20:            	
21:            	if(c == 0)
22:            		return 0.0;
23:            	sign = 0;
24:            	if(c < 0) {
25:            		c = -c;
26:            		sign = 1;
27:            	}
28:            	exp = 127+15;
29:            	// normalize 32 bits to 24 first
30:            	while(c & ~0xFFFFFFUL) {
31:            		*(unsigned long int *)&c >>= 1;
32:            		exp++;
33:            	}
34:            	f1_as_mant1 = c;
35:            	__ftpack(&f1_as_mant1, exp);
36:            	if(sign)
37:            		f1 = -f1;
38:            	return f1;
39:            }
40:            #else
41:            float
42:            __altoft(signed long int c)
43:            {
44:            	unsigned char exp, sign;
45:            	sign = 0;
1421  01AB     CLRF f2
46:            	exp = 127+15;
1422  308E     MOVLW 0x8E
1423  00FC     MOVWF product
1424  087C     MOVF product, W
1425  00AA     MOVWF exp
47:            	if (c < 0) {
1426  1FFB     BTFSS c, 0x7
1427  2C35     GOTO 0x435
48:            		c = -c;
1428  09F8     COMF c, F
1429  09F9     COMF counter, F
142A  09FA     COMF quotient, F
142B  09FB     COMF c, F
142C  0AF8     INCF c, F
142D  1903     BTFSC STATUS, 0x2
142E  0AF9     INCF counter, F
142F  1903     BTFSC STATUS, 0x2
1430  0AFA     INCF quotient, F
1431  1903     BTFSC STATUS, 0x2
1432  0AFB     INCF c, F
49:            		sign = 1;
1433  01AB     CLRF f2
1434  0AAB     INCF f2, F
50:            	}
51:            	// normalize 32 bits to 24 first
52:            	while(c & ~0xFFFFFFUL) {
1435  30FF     MOVLW 0xFF
1436  057B     ANDWF c, W
1437  1903     BTFSC STATUS, 0x2
1438  2C45     GOTO 0x445
1444  2C35     GOTO 0x435
53:            		*(unsigned long int *)&c >>= 1;
1439  3001     MOVLW 0x1
143A  36FB     LSRF c, F
143B  0CFA     RRF quotient, F
143C  0CF9     RRF counter, F
143D  0CF8     RRF c, F
143E  0B89     DECFSZ WREG, F
143F  2C3A     GOTO 0x43A
54:            		exp++;
1440  3001     MOVLW 0x1
1441  00FC     MOVWF product
1442  087C     MOVF product, W
1443  07AA     ADDWF exp, F
55:            	}
56:            	return __ftpack((__int24)c, exp, sign); 
1445  0878     MOVF c, W
1446  00F0     MOVWF __pcstackCOMMON
1447  0879     MOVF counter, W
1448  00F1     MOVWF c
1449  087A     MOVF quotient, W
144A  00F2     MOVWF dividend
144B  082A     MOVF exp, W
144C  00FC     MOVWF product
144D  087C     MOVF product, W
144E  00F3     MOVWF exp
144F  082B     MOVF f2, W
1450  00FD     MOVWF exp
1451  087D     MOVF exp, W
1452  00F4     MOVWF sign
1453  3188     MOVLP 0x8
1454  201C     CALL 0x1C
1455  0870     MOVF __pcstackCOMMON, W
1456  00F8     MOVWF c
1457  0871     MOVF c, W
1458  00F9     MOVWF counter
1459  0872     MOVF dividend, W
145A  00FA     MOVWF quotient
57:            }
145B  0008     RETURN
58:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/__lldiv.c  -----------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             __lldiv(unsigned long int divisor, unsigned long int dividend)
6:             #else
7:             __lldiv(unsigned long int dividend, unsigned long int divisor)
8:             #endif
9:             {
10:            	unsigned long int	quotient;
11:            	unsigned char	counter;
12:            
13:            	quotient = 0;
1583  3000     MOVLW 0x0
1584  00FC     MOVWF product
1585  3000     MOVLW 0x0
1586  00FB     MOVWF c
1587  3000     MOVLW 0x0
1588  00FA     MOVWF quotient
1589  3000     MOVLW 0x0
158A  00F9     MOVWF counter
14:            	if(divisor != 0) {
158B  0873     MOVF exp, W
158C  0472     IORWF dividend, W
158D  0471     IORWF c, W
158E  0470     IORWF __pcstackCOMMON, W
158F  1903     BTFSC STATUS, 0x2
1590  2DCC     GOTO 0x5CC
15:            		counter = 1;
1591  01FD     CLRF exp
1592  0AFD     INCF exp, F
16:            		while((divisor & 0x80000000UL) == 0) {
1593  1BF3     BTFSC exp, 0x7
1594  2DA1     GOTO 0x5A1
15A0  2D93     GOTO 0x593
17:            			divisor <<= 1;
1595  3001     MOVLW 0x1
1596  35F0     LSLF __pcstackCOMMON, F
1597  0DF1     RLF c, F
1598  0DF2     RLF dividend, F
1599  0DF3     RLF exp, F
159A  0B89     DECFSZ WREG, F
159B  2D96     GOTO 0x596
18:            			counter++;
159C  3001     MOVLW 0x1
159D  00F8     MOVWF c
159E  0878     MOVF c, W
159F  07FD     ADDWF exp, F
19:            		}
20:            		do {
21:            			quotient <<= 1;
15A1  3001     MOVLW 0x1
15A2  35F9     LSLF counter, F
15A3  0DFA     RLF quotient, F
15A4  0DFB     RLF c, F
15A5  0DFC     RLF product, F
15A6  0B89     DECFSZ WREG, F
15A7  2DA2     GOTO 0x5A2
22:            			if(divisor <= dividend) {
15A8  0873     MOVF exp, W
15A9  0277     SUBWF divisor, W
15AA  1D03     BTFSS STATUS, 0x2
15AB  2DB6     GOTO 0x5B6
15AC  0872     MOVF dividend, W
15AD  0276     SUBWF divisor, W
15AE  1D03     BTFSS STATUS, 0x2
15AF  2DB6     GOTO 0x5B6
15B0  0871     MOVF c, W
15B1  0275     SUBWF rem, W
15B2  1D03     BTFSS STATUS, 0x2
15B3  2DB6     GOTO 0x5B6
15B4  0870     MOVF __pcstackCOMMON, W
15B5  0274     SUBWF sign, W
15B6  1C03     BTFSS STATUS, 0x0
15B7  2DC1     GOTO 0x5C1
23:            				dividend -= divisor;
15B8  0870     MOVF __pcstackCOMMON, W
15B9  02F4     SUBWF sign, F
15BA  0871     MOVF c, W
15BB  3BF5     SUBWFB rem, F
15BC  0872     MOVF dividend, W
15BD  3BF6     SUBWFB divisor, F
15BE  0873     MOVF exp, W
15BF  3BF7     SUBWFB divisor, F
24:            				quotient |= 1;
15C0  1479     BSF counter, 0x0
25:            			}
26:            			divisor >>= 1;
15C1  3001     MOVLW 0x1
15C2  36F3     LSRF exp, F
15C3  0CF2     RRF dividend, F
15C4  0CF1     RRF c, F
15C5  0CF0     RRF __pcstackCOMMON, F
15C6  0B89     DECFSZ WREG, F
15C7  2DC2     GOTO 0x5C2
27:            		} while(--counter != 0);
15C8  3001     MOVLW 0x1
15C9  02FD     SUBWF exp, F
15CA  1D03     BTFSS STATUS, 0x2
15CB  2DA1     GOTO 0x5A1
28:            	}
29:            	return quotient;
15CC  087C     MOVF product, W
15CD  00F3     MOVWF exp
15CE  087B     MOVF c, W
15CF  00F2     MOVWF dividend
15D0  087A     MOVF quotient, W
15D1  00F1     MOVWF c
15D2  0879     MOVF counter, W
15D3  00F0     MOVWF __pcstackCOMMON
30:            }
15D4  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c90/common/Umul16.c  ------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
1304  01FC     CLRF product
1305  01FD     CLRF exp
44:            	do {
45:            		if(multiplier & 1)
1306  1C24     BTFSS multiplier, 0x0
1307  2B0C     GOTO 0x30C
46:            			product += multiplicand;
1308  0826     MOVF multiplicand, W
1309  07FC     ADDWF product, F
130A  0827     MOVF f1, W
130B  3DFD     ADDWFC exp, F
47:            		multiplicand <<= 1;
130C  3001     MOVLW 0x1
130D  35A6     LSLF multiplicand, F
130E  0DA7     RLF f1, F
130F  0B89     DECFSZ WREG, F
1310  2B0D     GOTO 0x30D
48:            		multiplier >>= 1;
1311  3001     MOVLW 0x1
1312  36A5     LSRF exp1, F
1313  0CA4     RRF multiplier, F
1314  0B89     DECFSZ WREG, F
1315  2B12     GOTO 0x312
49:            	} while(multiplier != 0);
1316  0824     MOVF multiplier, W
1317  0425     IORWF exp1, W
1318  1D03     BTFSS STATUS, 0x2
1319  2B06     GOTO 0x306
50:            
51:            #endif
52:                    return product;
131A  087D     MOVF exp, W
131B  00A5     MOVWF exp1
131C  087C     MOVF product, W
131D  00A4     MOVWF multiplier
53:            }
131E  0008     RETURN
